{
  "custom": {
    "design": null,
    "heatmap_format": {
      "colorScale": {
        "inverse": false,
        "max": "",
        "min": "",
        "ranges": [
          {
            "color": "#FFFFFF",
            "foreColor": "#FFFFFF",
            "from": 0,
            "name": " ",
            "to": 0
          },
          {
            "color": "#00800080",
            "foreColor": "#000000",
            "from": "0.000000000000000000001",
            "name": "1σ"
          },
          {
            "color": "#98FB9880",
            "foreColor": "#000000",
            "name": "2σ"
          },
          {
            "color": "#FFB7B780",
            "foreColor": "#000000",
            "name": "3σ"
          },
          {
            "color": "#FF555580",
            "foreColor": "#000000",
            "name": "5σ"
          },
          {
            "color": "#FF000080",
            "foreColor": "#000000",
            "name": "\u003e5σ"
          },
          {
            "color": "#AED6F180",
            "foreColor": "#000000",
            "name": "-1σ",
            "to": "-0.000000000000000000001"
          },
          {
            "color": "#5DADE280",
            "foreColor": "#000000",
            "name": "-2σ"
          },
          {
            "color": "#2E86C180",
            "foreColor": "#000000",
            "name": "-3σ"
          },
          {
            "color": "#21618C80",
            "foreColor": "#000000",
            "name": "-5σ"
          },
          {
            "color": "#15436080",
            "foreColor": "#000000",
            "name": "\u003c-5σ"
          }
        ]
      },
      "distributed": false,
      "enableShades": false,
      "radius": 2,
      "reverseNegativeShade": false,
      "shadeIntensity": 0.8,
      "useFillColorAsStroke": false
    },
    "key": "value",
    "line": {},
    "scale": {},
    "selection": {}
  },
  "params": {
    "timeZoneID": "Pacific/Auckland"
  },
  "propConfig": {
    "custom.aggregator": {
      "binding": {
        "config": {
          "enableValueCache": false,
          "parameters": {
            "end_dt": "{view.custom.end_dt}",
            "line_id": "{/root/Selections/selection_line.props.value}",
            "material": "{/root/Selections/selection_material.props.value}",
            "scale_id": "{/root/Selections/selection_scale.props.value}"
          },
          "queryPath": "Weight_Q/Weight_Average",
          "returnFormat": "json"
        },
        "transforms": [
          {
            "code": "\t\n\timport system\n\tfrom java.util import Calendar, TimeZone, Locale\n\tfrom java.text import SimpleDateFormat\n\t\n\t\n\tdef aggregateData(queryResults, timeZoneId):\n\t    yearlyData \u003d initializeYearlyData(timeZoneId)\n\t\n\t    for record in queryResults:\n\t        timestamp \u003d system.date.fromMillis(record[\u0027time_start\u0027])\n\t        calendar \u003d Calendar.getInstance(TimeZone.getTimeZone(timeZoneId))\n\t        calendar.setTime(timestamp)\n\t        monthIndex \u003d calendar.get(Calendar.MONTH)  # Zero-based indexing for months\n\t        dayIndex \u003d calendar.get(Calendar.DAY_OF_MONTH) - 1  # Zero-based indexing for days\n\t\n\t        updateDataStructure(yearlyData[monthIndex][\u0027days\u0027][dayIndex], record)\n\t        updateDataStructure(yearlyData[monthIndex][\u0027summary\u0027], record)\n\t\n\t    # Calculate final values for each day and month\n\t    for monthData in yearlyData:\n\t        for dayData in monthData[\u0027days\u0027]:\n\t            calculateFinalValues(dayData)\n\t        calculateFinalValues(monthData[\u0027summary\u0027])\n\t\n\t    return yearlyData\n\t\n\tdef initializeYearlyData(timeZoneId):\n\t    yearlyData \u003d []\n\t    for month in range(12):  # For each month\n\t        calendar \u003d Calendar.getInstance(TimeZone.getTimeZone(timeZoneId))\n\t        calendar.set(Calendar.MONTH, month)\n\t        monthName \u003d calendar.getDisplayName(Calendar.MONTH, Calendar.LONG, Locale.getDefault())\n\t        yearlyData.append({\n\t            \u0027days\u0027: initializeDaysOfMonth(calendar),\n\t            \u0027summary\u0027: initializeSummaryStructure(monthName)\n\t        })\n\t    return yearlyData\n\t\n\tdef initializeDaysOfMonth(calendar):\n\t    daysInMonth \u003d []\n\t    maxDay \u003d calendar.getActualMaximum(Calendar.DAY_OF_MONTH)\n\t    year \u003d calendar.get(Calendar.YEAR)\n\t    month \u003d calendar.get(Calendar.MONTH)\n\t    for day in range(1, maxDay + 1):  # One-based indexing\n\t        calendar.set(Calendar.YEAR, year)\n\t        calendar.set(Calendar.MONTH, month)\n\t        calendar.set(Calendar.DAY_OF_MONTH, day)\n\t        calendar.set(Calendar.HOUR_OF_DAY, 0)  # Set hour to midnight\n\t        calendar.set(Calendar.MINUTE, 0)       # Set minute to 0\n\t        calendar.set(Calendar.SECOND, 0)       # Set second to 0\n\t        calendar.set(Calendar.MILLISECOND, 0)  # Ensure millisecond is 0 for completeness\n\t        \n\t        timestamp \u003d system.date.toMillis(calendar.getTime())\n\t        daysInMonth.append({\u0027x\u0027: timestamp, \u0027weight_avg\u0027: 0, \u0027count\u0027: 0, \u0027weight_diff\u0027: 0, \u0027metal_rejects\u0027:0, \u0027weight_rejects\u0027:0})\n\t    return daysInMonth\n\t\n\tdef initializeSummaryStructure(monthName):\n\t    summary \u003d initializeDataStructure()\n\t    summary[\u0027x\u0027] \u003d monthName\n\t    return summary\n\t\n\tdef initializeDataStructure():\n\t    return {\u0027weight_avg\u0027: 0, \u0027count\u0027: 0, \u0027weight_diff\u0027: 0, \u0027metal_rejects\u0027:0, \u0027weight_rejects\u0027:0}\n\t\n\tdef updateDataStructure(data, record):\n\t    data[\u0027weight_avg\u0027] +\u003d record[\u0027weight_sum\u0027]\n\t    data[\u0027count\u0027] +\u003d record[\u0027count\u0027]\n\t    \n\t    if(record[\u0027metal_rejects\u0027]):\n\t    \tdata[\u0027metal_rejects\u0027] +\u003d int(record[\u0027metal_rejects\u0027])\n\t    \n\t    if(record[\u0027weight_rejects\u0027]):\n\t    \tdata[\u0027weight_rejects\u0027] +\u003d int(record[\u0027weight_rejects\u0027])\n\t    \n\t    data[\u0027weight_diff\u0027] +\u003d record[\u0027weight_diff\u0027]\n\t\n\tdef calculateFinalValues(data):\n\t    if data[\u0027count\u0027] \u003e 0:\n\t        data[\u0027weight_avg\u0027] \u003d data[\u0027weight_avg\u0027] / data[\u0027count\u0027]\n\t    data[\u0027weight_diff\u0027] \u003d data[\u0027weight_diff\u0027] * self.custom.scale.conversion_factor / 1000\n\t\n\ttimeZoneId \u003d self.params.timeZoneID\n\taggregatedData \u003d aggregateData(value, timeZoneId)\n\tself.getChild(\"root\").getChild(\"Data\").getChild(\"ScrollBack\").meta.visible \u003d True\n\tself.getChild(\"root\").getChild(\"Data\").getChild(\"ScrollForward\").meta.visible \u003d True\n\t\n\treturn aggregatedData",
            "type": "script"
          }
        ],
        "type": "query"
      },
      "persistent": false
    },
    "custom.aggregator_day": {
      "binding": {
        "config": {
          "path": "view.custom.day_data"
        },
        "transforms": [
          {
            "code": "\t\n\t#CORE_P.Utils.errorPopup(\u0027DEBUG:\u0027 + str(value) + \u0027 - \u0027 + str(self.getChild(\"root\").getChild(\"Selections\").getChild(\"selection_material\").props.value))\n\n\tfrom java.util import Calendar, TimeZone\n\n\tif self.custom.selection.timestamp \u003d\u003d \u0027\u0027:\n\t    return []\n\t\n\t# Assuming start_timestamp is provided or determined somehow\n\tstart_timestamp \u003d self.custom.selection.timestamp\n\t\n\t# Get the time zone ID from a session property or another source\n\ttimeZoneId \u003d self.params.timeZoneID\n\ttz \u003d TimeZone.getTimeZone(timeZoneId)\n\t\n\t# Generate the list of all hourly timestamps\n\tall_hours \u003d [start_timestamp + 3600000 * i for i in range(24)]\n\t\n\t# Convert the value list to a dictionary for easier access\n\tdata_dict \u003d {bucket[\"time_start\"]: bucket for bucket in value}\n\t\n\t# Transform the data\n\ttransformed_data \u003d []\n\tfor hour_timestamp in all_hours:\n\t    # Create a calendar instance set to the hour_timestamp and the specified time zone\n\t    cal \u003d Calendar.getInstance(tz)\n\t    cal.setTimeInMillis(hour_timestamp)\n\t\n\t    # Format the hour string\n\t    hour_str \u003d \u0027{:02d}:00\u0027.format(cal.get(Calendar.HOUR_OF_DAY))\n\t\n\t    bucket \u003d data_dict.get(hour_timestamp)\n\t\n\t    if bucket:\n\t        # Data exists for this hour\n\t        y_values \u003d [\n\t            bucket[\"weight_min\"],\n\t            bucket.get(\"percentile25\", 0),\n\t            bucket.get(\"percentile50\", 0),\n\t            bucket.get(\"percentile75\", 0),\n\t            bucket[\"weight_max\"]\n\t        ]\n\t        if bucket[\"material\"] !\u003d 0.0:\n\t        \tmaterial \u003d bucket[\"material\"]\n\t        else:\n\t        \tmaterial \u003d \"None\"\n\t    else:\n\t        # No data for this hour, use empty or placeholder values\n\t        y_values \u003d []\n\t        material \u003d \u0027None\u0027\n\t\n\t    transformed_item \u003d {\n\t        \"x\": hour_str,\n\t        \"y\": y_values,\n\t        \"material\": material\n\t    }\n\t    transformed_data.append(transformed_item)\n\t\n\treturn transformed_data",
            "type": "script"
          }
        ],
        "type": "property"
      },
      "persistent": false
    },
    "custom.aggregator_day_bag": {
      "binding": {
        "config": {
          "path": "view.custom.day_data"
        },
        "transforms": [
          {
            "code": "\n    from java.util import Calendar, TimeZone\n\n    if self.custom.selection.timestamp \u003d\u003d \u0027\u0027:\n        return []\n\n    # Assuming start_timestamp is provided or determined somehow\n    start_timestamp \u003d self.custom.selection.timestamp\n\n    # Get the time zone ID from a session property or another source\n    timeZoneId \u003d self.params.timeZoneID\n    tz \u003d TimeZone.getTimeZone(timeZoneId)\n\n    # Generate the list of all hourly timestamps\n    all_hours \u003d [start_timestamp + 3600000 * i for i in range(24)]\n\n    # Convert the value list to a dictionary for easier access\n    data_dict \u003d {bucket[\"time_start\"]: bucket for bucket in value}\n\n    # Transform the data\n    transformed_data \u003d []\n    for hour_timestamp in all_hours:\n        # Create a calendar instance set to the hour_timestamp and the specified time zone\n        cal \u003d Calendar.getInstance(tz)\n        cal.setTimeInMillis(hour_timestamp)\n\n        # Format the hour string\n        hour_str \u003d \u0027{:02d}:00\u0027.format(cal.get(Calendar.HOUR_OF_DAY))\n\n        bucket \u003d data_dict.get(hour_timestamp)\n\n        if bucket:\n            # Data exists for this hour\n            y_values \u003d bucket[\"count\"]\n        else:\n            # No data for this hour, use empty or placeholder values\n            y_values \u003d 0\n\n        transformed_item \u003d {\n            \"x\": hour_str,\n            \"y\": y_values\n        }\n        transformed_data.append(transformed_item)\n\n    return transformed_data",
            "type": "script"
          }
        ],
        "type": "property"
      },
      "persistent": false
    },
    "custom.aggregator_day_sp": {
      "binding": {
        "config": {
          "path": "view.custom.day_data"
        },
        "transforms": [
          {
            "code": "\n    from java.util import Calendar, TimeZone\n\n    if self.custom.selection.timestamp \u003d\u003d \u0027\u0027:\n        return []\n\n    # Assuming start_timestamp is provided or determined somehow\n    start_timestamp \u003d self.custom.selection.timestamp\n\n    # Get the time zone ID from a session property or another source\n    timeZoneId \u003d self.params.timeZoneID\n    tz \u003d TimeZone.getTimeZone(timeZoneId)\n\n    # Generate the list of all hourly timestamps\n    all_hours \u003d [start_timestamp + 3600000 * i for i in range(24)]\n\n    # Convert the value list to a dictionary for easier access\n    data_dict \u003d {bucket[\"time_start\"]: bucket for bucket in value}\n\n    # Transform the data\n    transformed_data \u003d []\n    for hour_timestamp in all_hours:\n        # Create a calendar instance set to the hour_timestamp and the specified time zone\n        cal \u003d Calendar.getInstance(tz)\n        cal.setTimeInMillis(hour_timestamp)\n\n        # Format the hour string\n        hour_str \u003d \u0027{:02d}:00\u0027.format(cal.get(Calendar.HOUR_OF_DAY))\n\n        bucket \u003d data_dict.get(hour_timestamp)\n\n        if bucket:\n            # Data exists for this hour\n            # Check if \u0027sp_plc\u0027 is present and has a value; if not, fall back to \u0027sp\u0027\n            y_values \u003d bucket.get(\u0027sp_plc\u0027, bucket.get(\u0027sp\u0027, None))\n        else:\n            # No data for this hour, use empty or placeholder values\n            y_values \u003d None\n\n        transformed_item \u003d {\n            \"x\": hour_str,\n            \"y\": y_values\n        }\n        transformed_data.append(transformed_item)\n\n    return transformed_data",
            "type": "script"
          }
        ],
        "type": "property"
      },
      "persistent": false
    },
    "custom.aggregator_year": {
      "binding": {
        "config": {
          "struct": {
            "aggregator": "{view.custom.aggregator}",
            "scale": "{/root/Selections/selection_scale.props.value}",
            "stat": "{/root/Selections/selection_stat.props.value}"
          },
          "waitOnAll": false
        },
        "transforms": [
          {
            "code": "\n    import datetime\n    SeriesIndex\u003d-1\n    \n    end_dt \u003d self.custom.end_dt\n\t\n    # Get the current month and year\n    #current_month \u003d datetime.datetime.now().month\n    #current_year \u003d datetime.datetime.now().year\n    current_month \u003d end_dt.getMonth()+1\n    current_year \u003d end_dt.getYear()+ 1900\n\n    # Custom sorting function to correctly order months with respect to the current month and year\n    def sort_key(entry):\n        month_name \u003d entry[\"name\"]\n        month_number \u003d month_to_number.get(month_name, -1)\n        entry_year \u003d entry.get(\"year\", current_year)\n\n        # Calculate how far back in time each entry is from the current month and year\n        year_diff \u003d current_year - entry_year\n        month_diff \u003d current_month - month_number\n\n        # For entries from the previous year, adjust month_diff to reflect their actual distance from the current month\n        if year_diff \u003e 0:\n            month_diff +\u003d 12\n\n        return (year_diff, month_diff)\n\n    month_to_number \u003d {\n        \"January\": 1, \"February\": 2, \"March\": 3, \"April\": 4,\n        \"May\": 5, \"June\": 6, \"July\": 7, \"August\": 8,\n        \"September\": 9, \"October\": 10, \"November\": 11, \"December\": 12\n    }\n\n    monthlyData \u003d value[\u0027aggregator\u0027]\n\n    transformedData \u003d []\n\n    for month in monthlyData:\n        monthName \u003d month[\"summary\"][\"x\"]\n        dayData \u003d month[\"days\"]\n\n        monthDataArray \u003d []\n        allDaysAreZero \u003d False # Set to true if empty months should not be shown\n        for day in dayData:\n            dayNumber \u003d day[\"x\"]\n            weight_diff \u003d day[\"weight_diff\"]\n            weight_avg \u003d day[\"weight_avg\"]\n            count \u003d day[\"count\"]\n            \n            if count\u003e0:\n            \tavg_diff \u003d weight_diff/count*1000/self.custom.scale.conversion_factor\n            else:\n            \tavg_diff\u003d0\n\n            if weight_diff !\u003d 0 or weight_avg !\u003d 0 or count !\u003d 0:\n                allDaysAreZero \u003d False\n\n            monthDataArray.append({\n                \"x\": dayNumber,\n                \"y\": avg_diff,\n                \"y2\": weight_avg,      # weight_diff as y\n                \"y3\": weight_diff,      # weight_avg as y2\n                \"y4\": count            # count as y3\n            })\n\n        if not allDaysAreZero:\n            month_number \u003d month_to_number.get(monthName, -1)\n            if month_number \u003e current_month:\n                inferred_year \u003d current_year - 1\n            else:\n                inferred_year \u003d current_year\n\n            transformedData.append({\n                \"data\": monthDataArray,\n                \"name\": monthName,\n                \"year\": inferred_year,\n                \"zIndex\": month_number\n            })\n\n    # Sort the transformed data using the custom sort key\n    transformedData.sort(key\u003dsort_key)\n\n    return transformedData",
            "type": "script"
          }
        ],
        "type": "expr-struct"
      },
      "persistent": false
    },
    "custom.aggregator_year_metal_rejects": {
      "binding": {
        "config": {
          "struct": {
            "aggregator": "{view.custom.aggregator}",
            "scale": "{/root/Selections/selection_scale.props.value}",
            "stat": "{/root/Selections/selection_stat.props.value}"
          },
          "waitOnAll": false
        },
        "transforms": [
          {
            "code": "\n    import datetime\n    SeriesIndex\u003d-1\n    \n    end_dt \u003d self.custom.end_dt\n\t\n    # Get the current month and year\n    #current_month \u003d datetime.datetime.now().month\n    #current_year \u003d datetime.datetime.now().year\n    current_month \u003d end_dt.getMonth()+1\n    current_year \u003d end_dt.getYear()+ 1900\n\n    # Custom sorting function to correctly order months with respect to the current month and year\n    def sort_key(entry):\n        month_name \u003d entry[\"name\"]\n        month_number \u003d month_to_number.get(month_name, -1)\n        entry_year \u003d entry.get(\"year\", current_year)\n\n        # Calculate how far back in time each entry is from the current month and year\n        year_diff \u003d current_year - entry_year\n        month_diff \u003d current_month - month_number\n\n        # For entries from the previous year, adjust month_diff to reflect their actual distance from the current month\n        if year_diff \u003e 0:\n            month_diff +\u003d 12\n\n        return (year_diff, month_diff)\n\n    month_to_number \u003d {\n        \"January\": 1, \"February\": 2, \"March\": 3, \"April\": 4,\n        \"May\": 5, \"June\": 6, \"July\": 7, \"August\": 8,\n        \"September\": 9, \"October\": 10, \"November\": 11, \"December\": 12\n    }\n\n    monthlyData \u003d value[\u0027aggregator\u0027]\n\n    transformedData \u003d []\n\n    for month in monthlyData:\n        monthName \u003d month[\"summary\"][\"x\"]\n        dayData \u003d month[\"days\"]\n\n        monthDataArray \u003d []\n        allDaysAreZero \u003d False # Set to true if empty months should not be shown\n        for day in dayData:\n            dayNumber \u003d day[\"x\"]\n            weight_diff \u003d day[\"weight_diff\"]\n            weight_avg \u003d day[\"weight_avg\"]\n            count \u003d day[\"count\"]\n            metal_rejects \u003d day[\"metal_rejects\"]\n            \n            if count\u003e0:\n            \tavg_diff \u003d weight_diff/count*1000/self.custom.scale.conversion_factor\n            else:\n            \tavg_diff\u003d0\n\n            if weight_diff !\u003d 0 or weight_avg !\u003d 0 or count !\u003d 0:\n                allDaysAreZero \u003d False\n\n            monthDataArray.append({\n                \"x\": dayNumber,\n                #\"y\": avg_diff,\n                \"y\": metal_rejects,\n                \"y2\": metal_rejects, #weight_avg,      # weight_diff as y\n                \"y3\": metal_rejects, #weight_avg,      # weight_diff as y\n                #\"y3\": weight_diff,      # weight_avg as y2\n                \"y4\": count            # count as y3\n            })\n\n        if not allDaysAreZero:\n            month_number \u003d month_to_number.get(monthName, -1)\n            if month_number \u003e current_month:\n                inferred_year \u003d current_year - 1\n            else:\n                inferred_year \u003d current_year\n\n            transformedData.append({\n                \"data\": monthDataArray,\n                \"name\": monthName,\n                \"year\": inferred_year,\n                \"zIndex\": month_number\n            })\n\n    # Sort the transformed data using the custom sort key\n    transformedData.sort(key\u003dsort_key)\n\n    return transformedData",
            "type": "script"
          }
        ],
        "type": "expr-struct"
      },
      "persistent": false
    },
    "custom.aggregator_year_weight_rejects": {
      "binding": {
        "config": {
          "struct": {
            "aggregator": "{view.custom.aggregator}",
            "scale": "{/root/Selections/selection_scale.props.value}",
            "stat": "{/root/Selections/selection_stat.props.value}"
          },
          "waitOnAll": false
        },
        "transforms": [
          {
            "code": "\n    import datetime\n    SeriesIndex\u003d-1\n    \n    end_dt \u003d self.custom.end_dt\n\t\n    # Get the current month and year\n    #current_month \u003d datetime.datetime.now().month\n    #current_year \u003d datetime.datetime.now().year\n    current_month \u003d end_dt.getMonth()+1\n    current_year \u003d end_dt.getYear()+ 1900\n\n    # Custom sorting function to correctly order months with respect to the current month and year\n    def sort_key(entry):\n        month_name \u003d entry[\"name\"]\n        month_number \u003d month_to_number.get(month_name, -1)\n        entry_year \u003d entry.get(\"year\", current_year)\n\n        # Calculate how far back in time each entry is from the current month and year\n        year_diff \u003d current_year - entry_year\n        month_diff \u003d current_month - month_number\n\n        # For entries from the previous year, adjust month_diff to reflect their actual distance from the current month\n        if year_diff \u003e 0:\n            month_diff +\u003d 12\n\n        return (year_diff, month_diff)\n\n    month_to_number \u003d {\n        \"January\": 1, \"February\": 2, \"March\": 3, \"April\": 4,\n        \"May\": 5, \"June\": 6, \"July\": 7, \"August\": 8,\n        \"September\": 9, \"October\": 10, \"November\": 11, \"December\": 12\n    }\n\n    monthlyData \u003d value[\u0027aggregator\u0027]\n\n    transformedData \u003d []\n\n    for month in monthlyData:\n        monthName \u003d month[\"summary\"][\"x\"]\n        dayData \u003d month[\"days\"]\n\n        monthDataArray \u003d []\n        allDaysAreZero \u003d False # Set to true if empty months should not be shown\n        for day in dayData:\n            dayNumber \u003d day[\"x\"]\n            weight_diff \u003d day[\"weight_diff\"]\n            weight_avg \u003d day[\"weight_avg\"]\n            count \u003d day[\"count\"]\n            weight_rejects \u003d day[\"weight_rejects\"]\n            \n            if count\u003e0:\n            \tavg_diff \u003d weight_diff/count*1000/self.custom.scale.conversion_factor\n            else:\n            \tavg_diff\u003d0\n\n            if weight_diff !\u003d 0 or weight_avg !\u003d 0 or count !\u003d 0:\n                allDaysAreZero \u003d False\n\n            monthDataArray.append({\n                \"x\": dayNumber,\n                \"y\": weight_rejects,#avg_diff,\n                \"y2\": weight_rejects, #weight_avg,      # weight_diff as y\n                \"y3\": weight_rejects,#weight_diff,      # weight_avg as y2\n                \"y4\": count            # count as y3\n            })\n\n        if not allDaysAreZero:\n            month_number \u003d month_to_number.get(monthName, -1)\n            if month_number \u003e current_month:\n                inferred_year \u003d current_year - 1\n            else:\n                inferred_year \u003d current_year\n\n            transformedData.append({\n                \"data\": monthDataArray,\n                \"name\": monthName,\n                \"year\": inferred_year,\n                \"zIndex\": month_number\n            })\n\n    # Sort the transformed data using the custom sort key\n    transformedData.sort(key\u003dsort_key)\n\n    return transformedData",
            "type": "script"
          }
        ],
        "type": "expr-struct"
      },
      "persistent": false
    },
    "custom.day_data": {
      "binding": {
        "config": {
          "enableValueCache": false,
          "parameters": {
            "line_id": "{/root/Selections/selection_line.props.value}",
            "material": "{/root/Selections/selection_material.props.value}",
            "scale_id": "{/root/Selections/selection_scale.props.value}",
            "start": "{view.custom.selection.timestamp}"
          },
          "queryPath": "Weight_Q/Weight_Day",
          "returnFormat": "json"
        },
        "type": "query"
      },
      "persistent": false
    },
    "custom.end_dt": {
      "binding": {
        "config": {
          "path": "1"
        },
        "transforms": [
          {
            "code": "\treturn CORE_P.Time.currentTimestamp()",
            "type": "script"
          }
        ],
        "type": "property"
      },
      "persistent": false
    },
    "custom.heatmap_format": {
      "persistent": true
    },
    "custom.heatmap_format.colorScale.ranges[10].from": {
      "binding": {
        "config": {
          "expression": "-1000*{view.custom.scale.design}"
        },
        "type": "expr"
      }
    },
    "custom.heatmap_format.colorScale.ranges[10].to": {
      "binding": {
        "config": {
          "expression": "-5*{view.custom.scale.design}"
        },
        "type": "expr"
      }
    },
    "custom.heatmap_format.colorScale.ranges[1].to": {
      "binding": {
        "config": {
          "expression": "{view.custom.scale.design}"
        },
        "type": "expr"
      }
    },
    "custom.heatmap_format.colorScale.ranges[2].from": {
      "binding": {
        "config": {
          "expression": "{view.custom.scale.design}"
        },
        "type": "expr"
      }
    },
    "custom.heatmap_format.colorScale.ranges[2].to": {
      "binding": {
        "config": {
          "expression": "2*{view.custom.scale.design}"
        },
        "type": "expr"
      }
    },
    "custom.heatmap_format.colorScale.ranges[3].from": {
      "binding": {
        "config": {
          "expression": "2*{view.custom.scale.design}"
        },
        "type": "expr"
      }
    },
    "custom.heatmap_format.colorScale.ranges[3].to": {
      "binding": {
        "config": {
          "expression": "3*{view.custom.scale.design}"
        },
        "type": "expr"
      }
    },
    "custom.heatmap_format.colorScale.ranges[4].from": {
      "binding": {
        "config": {
          "expression": "3*{view.custom.scale.design}"
        },
        "type": "expr"
      }
    },
    "custom.heatmap_format.colorScale.ranges[4].to": {
      "binding": {
        "config": {
          "expression": "5*{view.custom.scale.design}"
        },
        "type": "expr"
      }
    },
    "custom.heatmap_format.colorScale.ranges[5].from": {
      "binding": {
        "config": {
          "expression": "5*{view.custom.scale.design}"
        },
        "type": "expr"
      }
    },
    "custom.heatmap_format.colorScale.ranges[5].to": {
      "binding": {
        "config": {
          "expression": "1000*{view.custom.scale.design}"
        },
        "type": "expr"
      }
    },
    "custom.heatmap_format.colorScale.ranges[6].from": {
      "binding": {
        "config": {
          "expression": "-{view.custom.scale.design}"
        },
        "type": "expr"
      }
    },
    "custom.heatmap_format.colorScale.ranges[7].from": {
      "binding": {
        "config": {
          "expression": "-2*{view.custom.scale.design}"
        },
        "type": "expr"
      }
    },
    "custom.heatmap_format.colorScale.ranges[7].to": {
      "binding": {
        "config": {
          "expression": "-{view.custom.scale.design}"
        },
        "type": "expr"
      }
    },
    "custom.heatmap_format.colorScale.ranges[8].from": {
      "binding": {
        "config": {
          "expression": "-3*{view.custom.scale.design}"
        },
        "type": "expr"
      }
    },
    "custom.heatmap_format.colorScale.ranges[8].to": {
      "binding": {
        "config": {
          "expression": "-2*{view.custom.scale.design}"
        },
        "type": "expr"
      }
    },
    "custom.heatmap_format.colorScale.ranges[9].from": {
      "binding": {
        "config": {
          "expression": "-5*{view.custom.scale.design}"
        },
        "type": "expr"
      }
    },
    "custom.heatmap_format.colorScale.ranges[9].to": {
      "binding": {
        "config": {
          "expression": "-3*{view.custom.scale.design}"
        },
        "type": "expr"
      }
    },
    "custom.key": {
      "persistent": true
    },
    "custom.line": {
      "binding": {
        "config": {
          "parameters": {
            "line_id": "{/root/Selections/selection_line.props.value}"
          },
          "queryPath": "Weight_Q/DB_Query/Get_Line_Info"
        },
        "transforms": [
          {
            "code": "\n    # Create an empty dictionary to hold the results\n    result \u003d {}\n\n    # Check if the dataset contains at least one row\n    if value.getRowCount() \u003e 0:\n        # Extract values from the first row\n        line_desc \u003d value.getValueAt(0, \"line_desc\")\n        line_weight_min \u003d value.getValueAt(0, \"line_weight_min\")\n        line_weight_max \u003d value.getValueAt(0, \"line_weight_max\")\n\n        # Assign these values to the keys \u0027design\u0027 and \u0027setpoint\u0027 in the result dictionary\n        result[\u0027Description\u0027] \u003d line_desc\n        result[\u0027MinWeight\u0027] \u003d line_weight_min\n        result[\u0027MaxWeight\u0027] \u003d line_weight_max\n    else:\n        # Handle the case where no rows are returned\n        result[\u0027Description\u0027] \u003d \u0027\u0027\n        result[\u0027MinWeight\u0027] \u003d 20000\n        result[\u0027MaxWeight\u0027] \u003d 30000\n\n    # Return the dictionary containing the design and setpoint\n    return result",
            "type": "script"
          }
        ],
        "type": "query"
      },
      "persistent": true
    },
    "custom.line.Description": {
      "persistent": false
    },
    "custom.line.MaxWeight": {
      "persistent": false
    },
    "custom.line.MinWeight": {
      "persistent": false
    },
    "custom.scale": {
      "binding": {
        "config": {
          "enableValueCache": false,
          "parameters": {
            "scale_id": "{/root/Selections/selection_scale.props.value}"
          },
          "queryPath": "Weight_Q/DB_Query/Get_Scale_Info"
        },
        "transforms": [
          {
            "code": "\n    # Create an empty dictionary to hold the results\n    result \u003d {}\n\n    # Check if the dataset contains at least one row\n    if value.getRowCount() \u003e 0:\n        # Extract values from the first row\n        filler_design \u003d value.getValueAt(0, \"filler_design\")\n        filler_sp \u003d value.getValueAt(0, \"filler_sp\")\n        unit_name \u003d value.getValueAt(0, \"unit_name\")\n        unit_conversion \u003d value.getValueAt(0, \"unit_conversion\")\n        scale_name \u003d value.getValueAt(0, \"scale_name\")\n\n        # Assign these values to the keys \u0027design\u0027 and \u0027setpoint\u0027 in the result dictionary\n        result[\u0027design\u0027] \u003d filler_design\n        result[\u0027setpoint\u0027] \u003d filler_sp\n        result[\u0027unit\u0027] \u003d unit_name\n        result[\u0027conversion_factor\u0027] \u003d unit_conversion\n        result[\u0027scale_name\u0027] \u003d scale_name\n    else:\n        # Handle the case where no rows are returned\n        result[\u0027design\u0027] \u003d 50\n        result[\u0027setpoint\u0027] \u003d 25000\n        result[\u0027unit\u0027] \u003d \u0027g\u0027\n        result[\u0027conversion_factor\u0027] \u003d 1\n        result[\u0027scale_name\u0027] \u003d \u0027Scale\u0027\n\n    # Return the dictionary containing the design and setpoint\n    return result",
            "type": "script"
          }
        ],
        "type": "query"
      },
      "persistent": true
    },
    "custom.scale.conversion_factor": {
      "persistent": false
    },
    "custom.scale.design": {
      "persistent": false
    },
    "custom.scale.scale_name": {
      "persistent": false
    },
    "custom.scale.setpoint": {
      "persistent": false
    },
    "custom.scale.unit": {
      "onChange": {
        "enabled": null,
        "script": "\tself.getChild(\"root\").getChild(\"Day\").getChild(\"dailychart\").refreshBinding(\u0027props.options.title.text\u0027)\n\t"
      },
      "persistent": false
    },
    "custom.selection": {
      "persistent": true
    },
    "custom.selection.datetime": {
      "binding": {
        "config": {
          "path": "view.custom.selection.timestamp"
        },
        "transforms": [
          {
            "formatType": "datetime",
            "formatValue": {
              "date": "full"
            },
            "type": "format"
          }
        ],
        "type": "property"
      }
    },
    "custom.selection.index_day": {
      "persistent": false
    },
    "custom.selection.index_series": {
      "persistent": false
    },
    "custom.selection.index_year": {
      "persistent": false
    },
    "custom.selection.timestamp": {
      "persistent": false
    },
    "params.timeZoneID": {
      "binding": {
        "config": {
          "path": "session.props.timeZoneId"
        },
        "type": "property"
      },
      "onChange": {
        "enabled": null,
        "script": "\t\n\ttry:\n\t\tfrom java.util import Calendar, TimeZone\n\t\t\n\t\t# Get the timezone ID from a session property or another source\n\t\ttimeZoneId \u003d self.view.params.timeZoneID\n\t\ttz \u003d TimeZone.getTimeZone(timeZoneId)\n\t\t\n\t\tself.refreshBinding(\"custom.aggregator\")\n\t\tself.refreshBinding(\"custom.aggregator_day\")\n\t\tself.refreshBinding(\"custom.aggregator_day_bag\")\n\t\tself.refreshBinding(\"custom.aggregator_day_sp\")\n\t\t\n\t\t # Retrieve the year from the series data\n\t\tseries_year \u003d self.custom.aggregator_year[self.custom.selection.index_series].year\n\t\t\n\t\t# Convert to seconds for Python datetime operations\n\t\ttimestamp_seconds \u003d self.custom.aggregator_year[self.custom.selection.index_series].data[self.custom.selection.index_day].x / 1000.0\n\t\t\n\t\t# Create a calendar instance, set the time and adjust to the specified timezone\n\t\tcalendar \u003d Calendar.getInstance(tz)\n\t\tcalendar.setTimeInMillis(long(timestamp_seconds * 1000))\n\t\t\n\t\t# Correctly set the year based on the series data\n\t\tcalendar.set(Calendar.YEAR, series_year)\n\t\t\n\t\t# Set hour, minute, second, and millisecond to 0 to get the start of the day\n\t\tcalendar.set(Calendar.HOUR_OF_DAY, 0)\n\t\tcalendar.set(Calendar.MINUTE, 0)\n\t\tcalendar.set(Calendar.SECOND, 0)\n\t\tcalendar.set(Calendar.MILLISECOND, 0)\n\t\t\n\t\t# Convert back to epoch milliseconds adjusted for the specified timezone\n\t\tmidnight_timestamp \u003d calendar.getTimeInMillis()\n\t\tself.view.custom.selection.timestamp \u003d midnight_timestamp\n\texcept:\n\t\treturn"
      },
      "paramDirection": "inout",
      "persistent": true
    }
  },
  "props": {
    "defaultSize": {
      "height": 4000,
      "width": 1920
    }
  },
  "root": {
    "children": [
      {
        "meta": {
          "name": "Header"
        },
        "position": {
          "basis": "32px",
          "shrink": 0
        },
        "props": {
          "params": {
            "icon": "material/format_list_bulleted",
            "text": "Weights Overview"
          },
          "path": "CORE_V/Headers/SubHeader"
        },
        "type": "ia.display.view"
      },
      {
        "meta": {
          "name": "CurrentSite"
        },
        "position": {
          "basis": "0px",
          "shrink": 0
        },
        "propConfig": {
          "props.params.site_id": {
            "onChange": {
              "enabled": null,
              "script": "\tself.view.custom.selection.index_day\u003d\u0027\u0027\n\tself.view.custom.selection.index_series\u003d\u0027\u0027\n\tself.view.custom.selection.timestamp\u003d\u0027\u0027\n\tself.view.custom.selection.datetime\u003d\u0027\u0027\n\tself.parent.getChild(\"Selections\").getChild(\"selection_line\").props.value\u003d0\n\tself.parent.getChild(\"Selections\").getChild(\"selection_scale\").props.value\u003d0"
            }
          }
        },
        "props": {
          "params": {
            "site": null,
            "site_id": null
          },
          "path": "CORE_V/Utils/CurrentSite"
        },
        "type": "ia.display.view"
      },
      {
        "children": [
          {
            "events": {
              "component": {
                "onActionPerformed": {
                  "config": {
                    "script": "\tself.parent.parent.getChild(\"Year\").getChild(\"heatmap\").refreshBinding(\"props.series\")"
                  },
                  "scope": "G",
                  "type": "script"
                }
              }
            },
            "meta": {
              "name": "selection_line",
              "tooltip": {
                "text": "Select Line"
              }
            },
            "position": {
              "basis": "200px",
              "shrink": 0
            },
            "propConfig": {
              "props.options": {
                "binding": {
                  "config": {
                    "enableValueCache": false,
                    "parameters": {
                      "site_id": "{.../CurrentSite.props.params.site_id}"
                    },
                    "queryPath": "Weight_Q/DB_Query/Get_Line",
                    "returnFormat": "dataset"
                  },
                  "transforms": [
                    {
                      "code": "\t\n\t# Create an empty list to hold our formatted data\n    formatted_data \u003d []\n\n    # Iterate through each row in the dataset\n    for row in range(value.getRowCount()):\n        # Extract line_id and line_name from the current row\n        line_id \u003d value.getValueAt(row, \"line_id\")\n        line_name \u003d value.getValueAt(row, \"line_name\")\n\n        # Create a dictionary with the \u0027value\u0027 and \u0027label\u0027 keys\n        item \u003d {\"value\": line_id, \"label\": line_name}\n\n        # Add the dictionary to our list\n        formatted_data.append(item)\n        \n    # Check if the formatted data has only one row\n\tif len(formatted_data) \u003d\u003d 1:\n\t    # Set self.props.value to the scale_id of the single row\n\t    self.props.value \u003d formatted_data[0][\u0027value\u0027]\n\telif len(formatted_data)\u003e1:\n\t\tself.props.value \u003d formatted_data[0][\u0027value\u0027]\n\n    # Return the formatted list\n    return formatted_data",
                      "type": "script"
                    }
                  ],
                  "type": "query"
                },
                "persistent": true
              },
              "props.value": {
                "onChange": {
                  "enabled": null,
                  "script": "\tself.getSibling(\"selection_scale\").props.value\u003d0\n\tself.view.custom.selection.index_day\u003d\u0027\u0027\n\tself.view.custom.selection.index_series\u003d\u0027\u0027\n\tself.view.custom.selection.index_year\u003d\u0027\u0027\n\tself.view.custom.selection.timestamp\u003d\u0027\u0027\n\tself.view.custom.selection.datetime\u003d\u0027\u0027"
                },
                "persistent": true
              }
            },
            "props": {
              "options": [
                {
                  "label": "Bag Line 1",
                  "value": 1
                },
                {
                  "label": "Bottle Line 1",
                  "value": 2
                }
              ],
              "placeholder": {
                "text": "Select Line..."
              },
              "style": {
                "marginBottom": 2,
                "marginLeft": 10,
                "marginRight": 10,
                "marginTop": 2
              },
              "value": 1
            },
            "type": "ia.input.dropdown"
          },
          {
            "events": {
              "component": {
                "onActionPerformed": {
                  "config": {
                    "script": "\tself.parent.parent.getChild(\"Year\").getChild(\"heatmap\").refreshBinding(\"props.series\")"
                  },
                  "scope": "G",
                  "type": "script"
                }
              }
            },
            "meta": {
              "name": "selection_scale",
              "tooltip": {
                "text": "Select Scale"
              }
            },
            "position": {
              "basis": "200px",
              "shrink": 0
            },
            "propConfig": {
              "props.options": {
                "binding": {
                  "config": {
                    "enableValueCache": false,
                    "parameters": {
                      "line_id": "{../selection_line.props.value}",
                      "site_id": "{.../CurrentSite.props.params.site_id}"
                    },
                    "queryPath": "Weight_Q/DB_Query/Get_Scale",
                    "returnFormat": "dataset"
                  },
                  "transforms": [
                    {
                      "code": "\t\n\t# Create an empty list to hold our formatted data\n    formatted_data \u003d []\n\n    # Iterate through each row in the dataset\n    for row in range(value.getRowCount()):\n        # Extract line_id and line_name from the current row\n        scale_id \u003d value.getValueAt(row, \"scale_id\")\n        scale_name \u003d value.getValueAt(row, \"scale_name\")\n\n        # Create a dictionary with the \u0027value\u0027 and \u0027label\u0027 keys\n        item \u003d {\"value\": scale_id, \"label\": scale_name}\n\n        # Add the dictionary to our list\n        formatted_data.append(item)\n        \n    # Check if the formatted data has only one row\n\tif len(formatted_data) \u003d\u003d 1:\n\t    # Set self.props.value to the scale_id of the single row\n\t    self.props.value \u003d formatted_data[0][\u0027value\u0027]\n\telif len(formatted_data)\u003e1:\n\t\tformatted_data.append({\"value\": 0, \"label\": \u0027All Fillers\u0027})\n\t\tself.props.value \u003d 0\n\t\t#self.props.value \u003d formatted_data[-1][\u0027value\u0027]\n\n    # Return the formatted list\n    return formatted_data\n",
                      "type": "script"
                    }
                  ],
                  "type": "query"
                },
                "persistent": true
              },
              "props.value": {
                "persistent": true
              }
            },
            "props": {
              "placeholder": {
                "text": "Select Scale..."
              },
              "style": {
                "marginBottom": 2,
                "marginRight": 10,
                "marginTop": 2
              },
              "value": 0
            },
            "type": "ia.input.dropdown"
          },
          {
            "events": {
              "component": {
                "onActionPerformed": {
                  "config": {
                    "script": "\tself.parent.parent.getChild(\"Year\").getChild(\"heatmap\").refreshBinding(\"props.series\")\n\tself.parent.parent.getChild(\"Year\").getChild(\"heatmap\").refreshBinding(\"props.options.plotOptions.heatmap\")"
                  },
                  "scope": "G",
                  "type": "script"
                }
              }
            },
            "meta": {
              "name": "selection_stat",
              "tooltip": {
                "text": "Select Stat To Show"
              }
            },
            "position": {
              "basis": "200px",
              "shrink": 0
            },
            "propConfig": {
              "props.options[0].label": {
                "binding": {
                  "config": {
                    "path": "view.custom.scale.unit"
                  },
                  "transforms": [
                    {
                      "code": "\tif value !\u003d\u0027No data\u0027:\n\t\treturn \u0027Average Weight [\u0027+value+\u0027]\u0027\n\telse:\n\t\treturn \u0027Average Weight\u0027",
                      "type": "script"
                    }
                  ],
                  "type": "property"
                }
              },
              "props.value": {
                "persistent": true
              }
            },
            "props": {
              "options": [
                {
                  "value": "weight_avg"
                },
                {
                  "label": "Units",
                  "value": "count"
                },
                {
                  "label": "Overage [kg]",
                  "value": "weight_diff"
                }
              ],
              "style": {
                "marginBottom": 2,
                "marginRight": 10,
                "marginTop": 2
              },
              "value": "weight_avg"
            },
            "type": "ia.input.dropdown"
          },
          {
            "events": {
              "component": {
                "onActionPerformed": {
                  "config": {
                    "script": "\tself.parent.parent.getChild(\"Year\").getChild(\"heatmap\").refreshBinding(\"props.series\")\n\tself.parent.parent.getChild(\"Year\").getChild(\"heatmap\").refreshBinding(\"props.options.plotOptions.heatmap\")"
                  },
                  "scope": "G",
                  "type": "script"
                }
              }
            },
            "meta": {
              "name": "selection_material",
              "tooltip": {
                "text": "Select Stat To Show"
              }
            },
            "position": {
              "basis": "200px",
              "shrink": 0
            },
            "propConfig": {
              "props.options": {
                "binding": {
                  "config": {
                    "parameters": {
                      "scale_id": "{../selection_scale.props.value}"
                    },
                    "queryPath": "Weight_Q/DB_Query/Get_Materials_Dropdown",
                    "returnFormat": "json"
                  },
                  "transforms": [
                    {
                      "code": "\treturn value\n\t#return [{\u0027value\u0027:\u0027\u0027,\u0027label\u0027:\u0027All Materials\u0027}] + CORE_P.Utils.datasetToDicts(value)",
                      "type": "script"
                    }
                  ],
                  "type": "query"
                }
              },
              "props.value": {
                "persistent": true
              }
            },
            "props": {
              "style": {
                "marginBottom": 2,
                "marginRight": 10,
                "marginTop": 2
              },
              "value": "All"
            },
            "type": "ia.input.dropdown"
          }
        ],
        "meta": {
          "name": "Selections"
        },
        "position": {
          "basis": "32px",
          "shrink": 0
        },
        "props": {
          "style": {
            "borderColor": "#808080",
            "borderStyle": "none",
            "borderWidth": 0.5,
            "marginBottom": 5,
            "marginLeft": 5,
            "marginRight": 5,
            "marginTop": 5,
            "overflow": "hidden",
            "overflowX": "hidden",
            "overflowY": "hidden"
          }
        },
        "type": "ia.container.flex"
      },
      {
        "children": [
          {
            "events": {
              "dom": {
                "onClick": {
                  "config": {
                    "script": "\tself.meta.visible \u003d False\n\tself.getSibling(\"ScrollForward\").meta.visible \u003d False\n\tself.view.custom.end_dt \u003d  CORE_P.Time.adjustTimestamp(self.view.custom.end_dt, offset_hours\u003d-(3*60*24))"
                  },
                  "scope": "G",
                  "type": "script"
                }
              }
            },
            "meta": {
              "name": "ScrollBack"
            },
            "position": {
              "basis": "30px"
            },
            "props": {
              "path": "material/arrow_back",
              "style": {
                "cursor": "pointer"
              }
            },
            "type": "ia.display.icon"
          },
          {
            "meta": {
              "name": "Month"
            },
            "position": {
              "basis": "100%"
            },
            "propConfig": {
              "props.columns[3].header.title": {
                "binding": {
                  "config": {
                    "path": "view.custom.scale.unit"
                  },
                  "transforms": [
                    {
                      "code": "\treturn \u0027Weight Average [\u0027+value+\u0027]\u0027",
                      "type": "script"
                    }
                  ],
                  "type": "property"
                }
              },
              "props.columns[5].visible": {
                "binding": {
                  "config": {
                    "expression": "if({.../Selections/selection_scale.props.value}\u003d0,True, False)"
                  },
                  "type": "expr"
                }
              },
              "props.columns[6].visible": {
                "binding": {
                  "config": {
                    "expression": "if({.../Selections/selection_scale.props.value}\u003d0,True, False)"
                  },
                  "type": "expr"
                }
              },
              "props.data": {
                "binding": {
                  "config": {
                    "path": "view.custom.aggregator"
                  },
                  "transforms": [
                    {
                      "code": "\t\n\tfrom java.util import Calendar\n\t\n\tinput_data \u003d value\n\t\n\t# Initialize data arrays\n\tbag_counts \u003d []\n\tweight_avgs \u003d []\n\tweight_diffs \u003d []\n\t\n\t# Define month names for mapping numbers back to names later\n\tmonth_names \u003d [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \n\t               \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"]\n\t\n\t# Convert month names to numbers for sorting\n\tmonth_numbers \u003d {name: i + 1 for i, name in enumerate(month_names)}\n\t\n\t# Get current year and month\n\t#calendar \u003d Calendar.getInstance()\n\t#currentYear \u003d calendar.get(Calendar.YEAR)\n\t#currentMonth \u003d calendar.get(Calendar.MONTH) + 1  # Adjusting so January is 1, December is 12\n\t\n\tend_dt \u003d self.view.custom.end_dt\n\t\t\n    # Get the current month and year\n    #current_month \u003d datetime.datetime.now().month\n    #current_year \u003d datetime.datetime.now().year\n\tcurrentMonth \u003d end_dt.getMonth()+1\n\tcurrentYear \u003d end_dt.getYear()+ 1900\n    \t\n\t\n\t# Determine the year for each month and populate data arrays\n\tcombined_data \u003d []\n\tfor month in input_data:\n\t    summary \u003d month[\"summary\"]\n\t    month_number \u003d month_numbers[summary[\"x\"]]\n\t    year \u003d currentYear if month_number \u003c\u003d currentMonth else currentYear - 1\n\t    bag_count \u003d float(summary.get(\"count\", 0))\n\t    weight_avg \u003d float(summary.get(\"weight_avg\", 0.0))\n\t    weight_diff \u003d float(summary.get(\"weight_diff\", 0.0))\n\t    metal_rejects \u003d float(summary.get(\"metal_rejects\", 0.0))\n\t    weight_rejects \u003d float(summary.get(\"weight_rejects\", 0.0))\n\t    \n\t    combined_data.append([year, month_number, bag_count, weight_avg, weight_diff, metal_rejects, weight_rejects])\n\t\n\t# Sort the combined_data by year and month_number\n\tcombined_data.sort(key\u003dlambda x: (x[0], x[1]))\n\t\n\t# Replace month_number with month names for display, using the month_names list\n\tfor row in combined_data:\n\t    row[1] \u003d month_names[row[1] - 1]  # Convert month number back to name\n\t\n\tcombined_headers \u003d [\"Year\", \"Month\", \"Count\", \"Weight Avg\", \"Weight Diff\", \u0027Metal Rejects\u0027, \u0027Weight Rejects\u0027]\n\tcombined_dataset \u003d system.dataset.toDataSet(combined_headers, combined_data)\n\t\n\treturn combined_dataset",
                      "type": "script"
                    }
                  ],
                  "type": "property"
                }
              }
            },
            "props": {
              "bodyStyle": {
                "classes": "Weight_S/Framework/Card/Label"
              },
              "columns": [
                {
                  "align": "center",
                  "boolean": "checkbox",
                  "dateFormat": "MM/DD/YYYY",
                  "editable": false,
                  "field": "Year",
                  "filter": {
                    "boolean": {
                      "condition": ""
                    },
                    "date": {
                      "condition": "",
                      "value": ""
                    },
                    "enabled": false,
                    "number": {
                      "condition": "",
                      "value": ""
                    },
                    "string": {
                      "condition": "",
                      "value": ""
                    },
                    "visible": "on-hover"
                  },
                  "footer": {
                    "align": "center",
                    "justify": "left",
                    "style": {
                      "classes": ""
                    },
                    "title": ""
                  },
                  "header": {
                    "align": "center",
                    "justify": "left",
                    "style": {
                      "classes": ""
                    },
                    "title": "Year"
                  },
                  "justify": "left",
                  "nullFormat": {
                    "includeNullStrings": false,
                    "nullFormatValue": "",
                    "strict": false
                  },
                  "number": "value",
                  "numberFormat": "none",
                  "progressBar": {
                    "bar": {
                      "color": "",
                      "style": {
                        "classes": ""
                      }
                    },
                    "max": 100,
                    "min": 0,
                    "track": {
                      "color": "",
                      "style": {
                        "classes": ""
                      }
                    },
                    "value": {
                      "enabled": true,
                      "format": "0,0.##",
                      "justify": "center",
                      "style": {
                        "classes": ""
                      }
                    }
                  },
                  "render": "auto",
                  "resizable": false,
                  "sort": "ascending",
                  "sortable": false,
                  "strictWidth": false,
                  "style": {
                    "classes": ""
                  },
                  "toggleSwitch": {
                    "color": {
                      "selected": "",
                      "unselected": ""
                    }
                  },
                  "viewParams": {},
                  "viewPath": "",
                  "visible": true,
                  "width": ""
                },
                {
                  "align": "center",
                  "boolean": "checkbox",
                  "dateFormat": "MM/DD/YYYY",
                  "editable": false,
                  "field": "Month",
                  "filter": {
                    "boolean": {
                      "condition": ""
                    },
                    "date": {
                      "condition": "",
                      "value": ""
                    },
                    "enabled": false,
                    "number": {
                      "condition": "",
                      "value": ""
                    },
                    "string": {
                      "condition": "",
                      "value": ""
                    },
                    "visible": "on-hover"
                  },
                  "footer": {
                    "align": "center",
                    "justify": "left",
                    "style": {
                      "classes": ""
                    },
                    "title": ""
                  },
                  "header": {
                    "align": "center",
                    "justify": "left",
                    "style": {
                      "classes": ""
                    },
                    "title": "Month"
                  },
                  "justify": "left",
                  "nullFormat": {
                    "includeNullStrings": false,
                    "nullFormatValue": "",
                    "strict": false
                  },
                  "number": "value",
                  "numberFormat": "0,0.##",
                  "progressBar": {
                    "bar": {
                      "color": "",
                      "style": {
                        "classes": ""
                      }
                    },
                    "max": 100,
                    "min": 0,
                    "track": {
                      "color": "",
                      "style": {
                        "classes": ""
                      }
                    },
                    "value": {
                      "enabled": true,
                      "format": "0,0.##",
                      "justify": "center",
                      "style": {
                        "classes": ""
                      }
                    }
                  },
                  "render": "auto",
                  "resizable": false,
                  "sort": "none",
                  "sortable": false,
                  "strictWidth": false,
                  "style": {
                    "classes": ""
                  },
                  "toggleSwitch": {
                    "color": {
                      "selected": "",
                      "unselected": ""
                    }
                  },
                  "viewParams": {},
                  "viewPath": "",
                  "visible": true,
                  "width": ""
                },
                {
                  "align": "center",
                  "boolean": "checkbox",
                  "dateFormat": "MM/DD/YYYY",
                  "editable": false,
                  "field": "Count",
                  "filter": {
                    "boolean": {
                      "condition": ""
                    },
                    "date": {
                      "condition": "",
                      "value": ""
                    },
                    "enabled": false,
                    "number": {
                      "condition": "",
                      "value": ""
                    },
                    "string": {
                      "condition": "",
                      "value": ""
                    },
                    "visible": "on-hover"
                  },
                  "footer": {
                    "align": "center",
                    "justify": "left",
                    "style": {
                      "classes": ""
                    },
                    "title": ""
                  },
                  "header": {
                    "align": "center",
                    "justify": "left",
                    "style": {
                      "classes": ""
                    },
                    "title": "Units"
                  },
                  "justify": "left",
                  "nullFormat": {
                    "includeNullStrings": false,
                    "nullFormatValue": "",
                    "strict": false
                  },
                  "number": "value",
                  "numberFormat": "0,0",
                  "progressBar": {
                    "bar": {
                      "color": "",
                      "style": {
                        "classes": ""
                      }
                    },
                    "max": 100,
                    "min": 0,
                    "track": {
                      "color": "",
                      "style": {
                        "classes": ""
                      }
                    },
                    "value": {
                      "enabled": true,
                      "format": "0,0.##",
                      "justify": "center",
                      "style": {
                        "classes": ""
                      }
                    }
                  },
                  "render": "auto",
                  "resizable": true,
                  "sort": "none",
                  "sortable": false,
                  "strictWidth": false,
                  "style": {
                    "classes": ""
                  },
                  "toggleSwitch": {
                    "color": {
                      "selected": "",
                      "unselected": ""
                    }
                  },
                  "viewParams": {},
                  "viewPath": "",
                  "visible": true,
                  "width": ""
                },
                {
                  "align": "center",
                  "boolean": "checkbox",
                  "dateFormat": "MM/DD/YYYY",
                  "editable": false,
                  "field": "Weight Avg",
                  "filter": {
                    "boolean": {
                      "condition": ""
                    },
                    "date": {
                      "condition": "",
                      "value": ""
                    },
                    "enabled": false,
                    "number": {
                      "condition": "",
                      "value": ""
                    },
                    "string": {
                      "condition": "",
                      "value": ""
                    },
                    "visible": "on-hover"
                  },
                  "footer": {
                    "align": "center",
                    "justify": "left",
                    "style": {
                      "classes": ""
                    },
                    "title": ""
                  },
                  "header": {
                    "align": "center",
                    "justify": "left",
                    "style": {
                      "classes": ""
                    }
                  },
                  "justify": "left",
                  "nullFormat": {
                    "includeNullStrings": false,
                    "nullFormatValue": "",
                    "strict": false
                  },
                  "number": "value",
                  "numberFormat": "0,0",
                  "progressBar": {
                    "bar": {
                      "color": "",
                      "style": {
                        "classes": ""
                      }
                    },
                    "max": 100,
                    "min": 0,
                    "track": {
                      "color": "",
                      "style": {
                        "classes": ""
                      }
                    },
                    "value": {
                      "enabled": true,
                      "format": "0,0.##",
                      "justify": "center",
                      "style": {
                        "classes": ""
                      }
                    }
                  },
                  "render": "auto",
                  "resizable": true,
                  "sort": "none",
                  "sortable": false,
                  "strictWidth": false,
                  "style": {
                    "classes": ""
                  },
                  "toggleSwitch": {
                    "color": {
                      "selected": "",
                      "unselected": ""
                    }
                  },
                  "viewParams": {},
                  "viewPath": "",
                  "visible": true,
                  "width": ""
                },
                {
                  "align": "center",
                  "boolean": "checkbox",
                  "dateFormat": "MM/DD/YYYY",
                  "editable": false,
                  "field": "Weight Diff",
                  "filter": {
                    "boolean": {
                      "condition": ""
                    },
                    "date": {
                      "condition": "",
                      "value": ""
                    },
                    "enabled": false,
                    "number": {
                      "condition": "",
                      "value": ""
                    },
                    "string": {
                      "condition": "",
                      "value": ""
                    },
                    "visible": "on-hover"
                  },
                  "footer": {
                    "align": "center",
                    "justify": "left",
                    "style": {
                      "classes": ""
                    },
                    "title": ""
                  },
                  "header": {
                    "align": "center",
                    "justify": "left",
                    "style": {
                      "classes": ""
                    },
                    "title": "Overage [kg]"
                  },
                  "justify": "left",
                  "nullFormat": {
                    "includeNullStrings": false,
                    "nullFormatValue": "",
                    "strict": false
                  },
                  "number": "value",
                  "numberFormat": "0,0",
                  "progressBar": {
                    "bar": {
                      "color": "",
                      "style": {
                        "classes": ""
                      }
                    },
                    "max": 100,
                    "min": 0,
                    "track": {
                      "color": "",
                      "style": {
                        "classes": ""
                      }
                    },
                    "value": {
                      "enabled": true,
                      "format": "0,0.##",
                      "justify": "center",
                      "style": {
                        "classes": ""
                      }
                    }
                  },
                  "render": "auto",
                  "resizable": true,
                  "sort": "none",
                  "sortable": false,
                  "strictWidth": false,
                  "style": {
                    "classes": ""
                  },
                  "toggleSwitch": {
                    "color": {
                      "selected": "",
                      "unselected": ""
                    }
                  },
                  "viewParams": {},
                  "viewPath": "",
                  "visible": true,
                  "width": ""
                },
                {
                  "align": "center",
                  "boolean": "checkbox",
                  "dateFormat": "MM/DD/YYYY",
                  "editable": false,
                  "field": "metal_rejects",
                  "filter": {
                    "boolean": {
                      "condition": ""
                    },
                    "date": {
                      "condition": "",
                      "value": ""
                    },
                    "enabled": false,
                    "number": {
                      "condition": "",
                      "value": ""
                    },
                    "string": {
                      "condition": "",
                      "value": ""
                    },
                    "visible": "on-hover"
                  },
                  "footer": {
                    "align": "center",
                    "justify": "left",
                    "style": {
                      "classes": ""
                    },
                    "title": ""
                  },
                  "header": {
                    "align": "center",
                    "justify": "center",
                    "style": {
                      "classes": ""
                    },
                    "title": "Metal Rejects"
                  },
                  "justify": "center",
                  "nullFormat": {
                    "includeNullStrings": false,
                    "nullFormatValue": "",
                    "strict": false
                  },
                  "number": "value",
                  "numberFormat": "0,0.##",
                  "progressBar": {
                    "bar": {
                      "color": "",
                      "style": {
                        "classes": ""
                      }
                    },
                    "max": 100,
                    "min": 0,
                    "track": {
                      "color": "",
                      "style": {
                        "classes": ""
                      }
                    },
                    "value": {
                      "enabled": true,
                      "format": "0,0.##",
                      "justify": "center",
                      "style": {
                        "classes": ""
                      }
                    }
                  },
                  "render": "string",
                  "resizable": true,
                  "sort": "none",
                  "sortable": true,
                  "strictWidth": false,
                  "style": {
                    "classes": ""
                  },
                  "toggleSwitch": {
                    "color": {
                      "selected": "",
                      "unselected": ""
                    }
                  },
                  "viewParams": {},
                  "viewPath": "",
                  "width": ""
                },
                {
                  "align": "center",
                  "boolean": "checkbox",
                  "dateFormat": "MM/DD/YYYY",
                  "editable": false,
                  "field": "weight_rejects",
                  "filter": {
                    "boolean": {
                      "condition": ""
                    },
                    "date": {
                      "condition": "",
                      "value": ""
                    },
                    "enabled": false,
                    "number": {
                      "condition": "",
                      "value": ""
                    },
                    "string": {
                      "condition": "",
                      "value": ""
                    },
                    "visible": "on-hover"
                  },
                  "footer": {
                    "align": "center",
                    "justify": "left",
                    "style": {
                      "classes": ""
                    },
                    "title": ""
                  },
                  "header": {
                    "align": "center",
                    "justify": "center",
                    "style": {
                      "classes": ""
                    },
                    "title": "Weight Rejects"
                  },
                  "justify": "center",
                  "nullFormat": {
                    "includeNullStrings": false,
                    "nullFormatValue": "",
                    "strict": false
                  },
                  "number": "value",
                  "numberFormat": "0,0.##",
                  "progressBar": {
                    "bar": {
                      "color": "",
                      "style": {
                        "classes": ""
                      }
                    },
                    "max": 100,
                    "min": 0,
                    "track": {
                      "color": "",
                      "style": {
                        "classes": ""
                      }
                    },
                    "value": {
                      "enabled": true,
                      "format": "0,0.##",
                      "justify": "center",
                      "style": {
                        "classes": ""
                      }
                    }
                  },
                  "render": "string",
                  "resizable": true,
                  "sort": "none",
                  "sortable": true,
                  "strictWidth": false,
                  "style": {
                    "classes": ""
                  },
                  "toggleSwitch": {
                    "color": {
                      "selected": "",
                      "unselected": ""
                    }
                  },
                  "viewParams": {},
                  "viewPath": "",
                  "width": ""
                }
              ],
              "headerGroupStyle": {
                "classes": "Weight_S/Framework/Card/Value"
              },
              "headerStyle": {
                "classes": "Weight_S/Framework/Card/Value"
              },
              "pager": {
                "bottom": false
              },
              "rows": {
                "height": "20px"
              },
              "style": {
                "paddingLeft": 4,
                "paddingRight": 4
              }
            },
            "type": "ia.display.table"
          },
          {
            "events": {
              "dom": {
                "onClick": {
                  "config": {
                    "script": "\tt \u003d CORE_P.Time.adjustTimestamp(self.view.custom.end_dt, offset_hours\u003d(3*60*24))\n\tif (t\u003eCORE_P.Time.currentTimestamp()):\t\n\t\tt\u003dCORE_P.Time.currentTimestamp()\n\telse:\n\t\tself.meta.visible \u003d False\n\t\tself.getSibling(\"ScrollBack\").meta.visible \u003d False\n\t\t\n\tself.view.custom.end_dt \u003d t\n\t"
                  },
                  "scope": "G",
                  "type": "script"
                }
              }
            },
            "meta": {
              "name": "ScrollForward"
            },
            "position": {
              "basis": "30px"
            },
            "props": {
              "path": "material/arrow_forward",
              "style": {
                "cursor": "pointer"
              }
            },
            "type": "ia.display.icon"
          }
        ],
        "meta": {
          "name": "Data"
        },
        "position": {
          "basis": "275px",
          "shrink": 0
        },
        "propConfig": {
          "position.display": {
            "binding": {
              "config": {
                "expression": "if({../Selections/selection_line.props.value}\u003d0,False,True)"
              },
              "type": "expr"
            }
          }
        },
        "props": {
          "style": {
            "borderColor": "#808080",
            "borderStyle": "solid",
            "borderWidth": 0.5,
            "marginBottom": 5,
            "marginLeft": 5,
            "marginRight": 5,
            "marginTop": 5,
            "overflow": "hidden",
            "overflowX": "hidden",
            "overflowY": "hidden"
          }
        },
        "type": "ia.container.flex"
      },
      {
        "children": [
          {
            "events": {
              "component": {
                "dataPointSelectionHandler": {
                  "config": {
                    "script": "\n    from java.util import Calendar, TimeZone\n\n    # Get the timezone ID from a session property or another source\n    timeZoneId \u003d self.view.params.timeZoneID\n    tz \u003d TimeZone.getTimeZone(timeZoneId)\n    \n    #Hide if no data exists for selected day\n\t\n    # Check if no data exists for the selected day\n    if self.props.series[event.seriesIndex].data[event.dataPointIndex].y \u003d\u003d 0:\n    \tself.view.custom.selection.timestamp \u003d \u0027\u0027\n        self.view.custom.selection.index_series \u003d \u0027\u0027\n        self.view.custom.selection.index_day \u003d \u0027\u0027\n        self.view.custom.selection.index_year \u003d \u0027\u0027\n        return  # Exit the function if no data\n\t\n\t# Hide with second click on same day\n    if event.seriesIndex \u003d\u003d self.view.custom.selection.index_series and event.dataPointIndex \u003d\u003d self.view.custom.selection.index_day:\n        self.view.custom.selection.timestamp \u003d \u0027\u0027\n        self.view.custom.selection.index_series \u003d \u0027\u0027\n        self.view.custom.selection.index_day \u003d \u0027\u0027\n        self.view.custom.selection.index_year \u003d \u0027\u0027\n        return\n    \n    # Retrieve the year from the series data\n    series_year \u003d self.props.series[event.seriesIndex].year\n\n    # Convert to seconds for Python datetime operations\n    timestamp_seconds \u003d self.props.series[event.seriesIndex].data[event.dataPointIndex].x / 1000.0\n    \n    # Create a calendar instance, set the time and adjust to the specified timezone\n    calendar \u003d Calendar.getInstance(tz)\n    calendar.setTimeInMillis(long(timestamp_seconds * 1000))\n    \n    # Correctly set the year based on the series data\n    calendar.set(Calendar.YEAR, series_year)\n    \n    # Set hour, minute, second, and millisecond to 0 to get the start of the day\n    calendar.set(Calendar.HOUR_OF_DAY, 0)\n    calendar.set(Calendar.MINUTE, 0)\n    calendar.set(Calendar.SECOND, 0)\n    calendar.set(Calendar.MILLISECOND, 0)\n    \n    # Convert back to epoch milliseconds adjusted for the specified timezone\n    midnight_timestamp \u003d calendar.getTimeInMillis()\n    self.view.custom.selection.timestamp \u003d midnight_timestamp\n    \n    self.view.custom.selection.index_series \u003d event.seriesIndex\n    self.view.custom.selection.index_day \u003d event.dataPointIndex\n    self.view.custom.selection.index_year \u003d series_year\n\t\n\n\t\n\n\n"
                  },
                  "scope": "G",
                  "type": "script"
                }
              }
            },
            "meta": {
              "name": "heatmap"
            },
            "position": {
              "basis": "100%",
              "shrink": 0
            },
            "propConfig": {
              "props.options.dataLabels.formatter": {
                "binding": {
                  "config": {
                    "struct": {
                      "factor": "{view.custom.scale.conversion_factor}",
                      "stat": "{.../Selections/selection_stat.props.value}"
                    },
                    "waitOnAll": true
                  },
                  "transforms": [
                    {
                      "code": "\t\n\tif value[\u0027factor\u0027] \u003d\u003d 1:\n\t    digits \u003d str(0)\n\telif value[\u0027factor\u0027] \u003e 10:\n\t    digits \u003d str(1)\n\telif value[\u0027factor\u0027] \u003e 100:\n\t    digits \u003d str(2)\n\t\n\t    \n\tif value[\u0027stat\u0027] \u003d\u003d \u0027weight_avg\u0027:\n\t    \n\t    return \u0027\u0027\u0027function(val, opts) {\n\t        // Retrieve y2 value from the opts object\n\t        var y2 \u003d opts.w.config.series[opts.seriesIndex].data[opts.dataPointIndex].y2;\n\t        // Format y2 to a fixed number with no decimal places\n\t        var formattedY2 \u003d y2.toFixed(\u0027\u0027\u0027+digits+\u0027\u0027\u0027);\n\t        // Return formatted number as a localized string\n\t        return formattedY2.toLocaleString();\n\t    }\u0027\u0027\u0027\n\t    \n\tif value[\u0027stat\u0027] \u003d\u003d \u0027weight_diff\u0027:\n\t    \n\t    return \u0027\u0027\u0027function(val, opts) {\n\t        // Retrieve y3 value from the opts object\n\t        var y3 \u003d opts.w.config.series[opts.seriesIndex].data[opts.dataPointIndex].y3;\n\t        // Format y3 to a fixed number with no decimal places\n\t        var formattedY3 \u003d y3.toFixed(0);\n\t        // Return formatted number as a localized string\n\t        return formattedY3.toLocaleString();\n\t    }\u0027\u0027\u0027\n\t    \n\tif value[\u0027stat\u0027] \u003d\u003d \u0027count\u0027:\n\t    \n\t    return \u0027\u0027\u0027function(val, opts) {\n\t        // Retrieve y4 value from the opts object\n\t        var y4 \u003d opts.w.config.series[opts.seriesIndex].data[opts.dataPointIndex].y4;\n\t        // Format y4 to a fixed number with no decimal places\n\t        var formattedY4 \u003d y4.toFixed(1);\n\t        // Return formatted number as a localized string\n\t        return formattedY4.toLocaleString();\n\t        }\u0027\u0027\u0027",
                      "type": "script"
                    }
                  ],
                  "type": "expr-struct"
                }
              },
              "props.options.plotOptions.heatmap": {
                "binding": {
                  "config": {
                    "path": "view.custom.heatmap_format"
                  },
                  "type": "property"
                }
              },
              "props.options.title.text": {
                "binding": {
                  "config": {
                    "struct": {
                      "description": "{view.custom.line.Description}",
                      "scale": "{view.custom.scale.scale_name}",
                      "unit": "{view.custom.scale.unit}"
                    },
                    "waitOnAll": true
                  },
                  "transforms": [
                    {
                      "code": "\tif value[\u0027description\u0027] !\u003d \u0027\u0027:\n\t\treturn  value[\u0027description\u0027] + \u0027 \u0027 + value[\u0027scale\u0027] + \u0027 - Weights are in \u0027 + value[\u0027unit\u0027] + \u0027. Overage is in kg. Filler accuracy σ set to: \u0027 + str(self.view.custom.scale.design) + \u0027 \u0027 + value[\u0027unit\u0027]\n\telse:\n\t\treturn \u0027Weights are in \u0027 + value[\u0027unit\u0027] + \u0027. Overage is in kg. Filler accuracy σ set to: \u0027 + str(self.view.custom.scale.design) + \u0027 \u0027 + value[\u0027unit\u0027]",
                      "type": "script"
                    }
                  ],
                  "type": "expr-struct"
                }
              },
              "props.options.tooltip.y.formatter": {
                "binding": {
                  "config": {
                    "expression": "{view.custom.scale.unit}"
                  },
                  "transforms": [
                    {
                      "code": "\n    # Convert the Python variable \u0027value\u0027 to a string and prepare it for JavaScript injection\n    value_str \u003d str(value)\n    \n    # Create the JavaScript function as a string, injecting \u0027value\u0027 correctly\n    return (\u0027\u0027\u0027function(value, { series, seriesIndex, dataPointIndex, w }) {\u0027\u0027\u0027\n            \u0027\u0027\u0027\\n    // Accessing the data for y, y2, y3, and y4\u0027\u0027\u0027\n            \u0027\u0027\u0027\\n    var data \u003d w.config.series[seriesIndex].data[dataPointIndex];\u0027\u0027\u0027\n            \u0027\u0027\u0027\\n    var y \u003d parseFloat(data.y).toFixed(0);  // Main value\u0027\u0027\u0027\n            \u0027\u0027\u0027\\n    var y2 \u003d parseFloat(data.y2).toFixed(0); // Additional value 1\u0027\u0027\u0027\n            \u0027\u0027\u0027\\n    var y3 \u003d parseFloat(data.y3).toFixed(1); // Additional value 2\u0027\u0027\u0027\n            \u0027\u0027\u0027\\n    var y4 \u003d parseFloat(data.y4).toFixed(0); // Additional value 3\u0027\u0027\u0027\n            \u0027\u0027\u0027\\n\u0027\u0027\u0027\n            \u0027\u0027\u0027\\n    // Concatenate the values with slashes in between\u0027\u0027\u0027\n            \u0027\u0027\u0027\\n    return \u0027Avg. Overage: \u0027 + y + \" \u0027\u0027\u0027 + value_str + \u0027\u0027\u0027 \" + \u0027 / Avg. Weight: \u0027 + y2 + \" \u0027\u0027\u0027 + value_str + \u0027\u0027\u0027 \"  + \u0027 / Overage: \u0027 + y3+ \" kg \"   + \u0027 / Units: \u0027 + y4;\u0027\u0027\u0027\n            \u0027\u0027\u0027\\n}\u0027\u0027\u0027)",
                      "type": "script"
                    }
                  ],
                  "type": "expr"
                }
              },
              "props.series": {
                "binding": {
                  "config": {
                    "path": "view.custom.aggregator_year"
                  },
                  "type": "property"
                }
              }
            },
            "props": {
              "options": {
                "annotations": {},
                "chart": {
                  "animations": {
                    "enabled": false
                  },
                  "background": "",
                  "events": {
                    "dataPointSelection": true
                  },
                  "fontFamily": "Roboto",
                  "foreColor": "#333",
                  "height": 220,
                  "toolbar": {
                    "show": false,
                    "tools": {
                      "zoom": false,
                      "zoomin": false,
                      "zoomout": false
                    }
                  },
                  "type": "heatmap",
                  "width": 480
                },
                "colors": [
                  "#FF0000"
                ],
                "dataLabels": {
                  "enabled": true,
                  "style": {
                    "fontSize": "10px",
                    "fontWeight": 700
                  }
                },
                "grid": {
                  "padding": {
                    "left": 15,
                    "right": 25
                  }
                },
                "legend": {
                  "fontSize": 14,
                  "itemMargin": {
                    "vertical": 0
                  },
                  "markers": {
                    "offsetY": 2,
                    "shape": "square",
                    "size": 10
                  },
                  "offsetY": 0,
                  "show": true
                },
                "plotOptions": {},
                "stroke": {
                  "colors": [
                    "#fff"
                  ],
                  "fill": {
                    "gradient": {
                      "colorStops": [],
                      "inverseColors": true,
                      "opacityFrom": 1,
                      "opacityTo": 1,
                      "shade": "dark",
                      "shadeIntensity": 0.5,
                      "stops": [
                        0,
                        50,
                        100
                      ],
                      "type": "horizontal"
                    },
                    "opacity": 0.85,
                    "type": "solid"
                  }
                },
                "theme": {
                  "palette": "palette4"
                },
                "title": {
                  "align": "center",
                  "style": {
                    "color": "#263238",
                    "fontFamily": "Roboto",
                    "fontSize": "12px",
                    "fontWeight": "normal"
                  }
                },
                "tooltip": {
                  "enabled": true,
                  "followCursor": true,
                  "marker": {
                    "show": true
                  },
                  "x": {
                    "show": true
                  },
                  "y": {
                    "show": true
                  }
                },
                "xaxis": {
                  "axisTicks": {
                    "show": false
                  },
                  "decimalsInFloat": 0,
                  "labels": {
                    "show": false,
                    "style": {},
                    "trim": true
                  },
                  "tickAmount": 31,
                  "tickPlacement": "numeric",
                  "title": {
                    "style": {
                      "fontWeight": 700
                    }
                  },
                  "tooltip": {
                    "enabled": false
                  },
                  "type": "datetime"
                },
                "yaxis": {
                  "labels": {
                    "style": {}
                  },
                  "tickAmount": 5,
                  "title": {
                    "style": {
                      "fontWeight": 700
                    }
                  }
                }
              },
              "style": {
                "marginBottom": 10,
                "marginLeft": 10,
                "marginRight": 10,
                "marginTop": 10
              },
              "type": "heatmap"
            },
            "type": "kyvislabs.display.apexchart"
          }
        ],
        "meta": {
          "name": "Year"
        },
        "position": {
          "shrink": 0
        },
        "propConfig": {
          "position.basis": {
            "binding": {
              "config": {
                "expression": "concat(toStr(((len({./heatmap.props.series})+2)*25)),\u0027px\u0027)"
              },
              "type": "expr"
            }
          },
          "position.display": {
            "binding": {
              "config": {
                "expression": "if({../Selections/selection_line.props.value}\u003d0,False,True)"
              },
              "type": "expr"
            }
          }
        },
        "props": {
          "alignContent": "flex-start",
          "style": {
            "borderColor": "#808080",
            "borderStyle": "solid",
            "borderWidth": 0.5,
            "marginBottom": 5,
            "marginLeft": 5,
            "marginRight": 5,
            "marginTop": 5,
            "overflow": "hidden",
            "overflowX": "hidden",
            "overflowY": "hidden"
          }
        },
        "type": "ia.container.flex"
      },
      {
        "children": [
          {
            "meta": {
              "name": "dailychart"
            },
            "position": {
              "basis": "100%",
              "shrink": 0
            },
            "propConfig": {
              "position.display": {
                "binding": {
                  "config": {
                    "path": "view.custom.selection.timestamp"
                  },
                  "transforms": [
                    {
                      "code": "\tif value\u003d\u003d\u0027\u0027:\n\t\treturn False\n\telse:\n\t\treturn True",
                      "type": "script"
                    }
                  ],
                  "type": "property"
                }
              },
              "props.options.title.text": {
                "binding": {
                  "config": {
                    "path": "view.custom.selection.datetime"
                  },
                  "type": "property"
                }
              },
              "props.options.tooltip.custom": {
                "binding": {
                  "config": {
                    "expression": "now(0)"
                  },
                  "transforms": [
                    {
                      "code": "\t\n\tscript\u003d\u0027\u0027\u0027function({series, seriesIndex, dataPointIndex, w}) {\n\t    let htmlContent \u003d \u0027\u003cdiv class\u003d\"arrow_box\" style\u003d\"\u0027\n\t        + \u0027background-color: #f9f9f9; padding: 10px; border: 1px solid #ddd; \u0027\n\t        + \u0027box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.2); border-radius: 5px; \u0027\n\t        + \u0027font-family: Arial, sans-serif; font-size: 14px; color: #333; \u0027\n\t        + \u0027line-height: 1; text-align: left;\"\u003e\u0027;\n\t\n\t    const formatValue \u003d value \u003d\u003e Math.round(value).toString();\n\t    var data \u003d w.config.series[seriesIndex].data[dataPointIndex];\n\t\n\t\n\t    // Added margin-right to the span for spacing\n\t    htmlContent +\u003d\u0027\u003cdiv style\u003d\"display: flex; justify-content: space-between;\"\u003e\u003cspan style\u003d\"margin-right: 10px;\"\u003eMaterial:\u003c/span\u003e\u003cb\u003e\u0027 + data.material + \u0027\u003c/b\u003e\u003c/div\u003e\u0027\n\t    \t\t\t + \u0027\u003cbr\u003e\u0027 // Line break before SP\n\t    \t\t\t  +\u0027\u003cdiv style\u003d\"display: flex; justify-content: space-between;\"\u003e\u003cspan style\u003d\"margin-right: 10px;\"\u003eMaximum:\u003c/span\u003e\u003cb\u003e\u0027 + formatValue(w.globals.seriesCandleC[0][dataPointIndex]) + \u0027\u003c/b\u003e\u003c/div\u003e\u0027\n\t                 + \u0027\u003cdiv style\u003d\"display: flex; justify-content: space-between;\"\u003e\u003cspan style\u003d\"margin-right: 10px;\"\u003e75%:\u003c/span\u003e\u003cb\u003e\u0027 + formatValue(w.globals.seriesCandleL[0][dataPointIndex]) + \u0027\u003c/b\u003e\u003c/div\u003e\u0027\n\t                 + \u0027\u003cdiv style\u003d\"display: flex; justify-content: space-between;\"\u003e\u003cspan style\u003d\"margin-right: 10px;\"\u003eMedian:\u003c/span\u003e\u003cb\u003e\u0027 + formatValue(w.globals.seriesCandleM[0][dataPointIndex]) + \u0027\u003c/b\u003e\u003c/div\u003e\u0027\n\t                 + \u0027\u003cdiv style\u003d\"display: flex; justify-content: space-between;\"\u003e\u003cspan style\u003d\"margin-right: 10px;\"\u003e25%:\u003c/span\u003e\u003cb\u003e\u0027 + formatValue(w.globals.seriesCandleH[0][dataPointIndex]) + \u0027\u003c/b\u003e\u003c/div\u003e\u0027\n\t                 + \u0027\u003cdiv style\u003d\"display: flex; justify-content: space-between;\"\u003e\u003cspan style\u003d\"margin-right: 10px;\"\u003eMinimum:\u003c/span\u003e\u003cb\u003e\u0027 + formatValue(w.globals.seriesCandleO[0][dataPointIndex]) + \u0027\u003c/b\u003e\u003c/div\u003e\u0027\n\t                 + \u0027\u003cbr\u003e\u0027 // Line break before Count\n\t                 + \u0027\u003cdiv style\u003d\"display: flex; justify-content: space-between;\"\u003e\u003cspan style\u003d\"margin-right: 10px;\"\u003eCount:\u003c/span\u003e\u003cb\u003e\u0027 + formatValue(series[1][dataPointIndex]) + \u0027\u003c/b\u003e\u003c/div\u003e\u0027\n\t                 + \u0027\u003cdiv style\u003d\"display: flex; justify-content: space-between;\"\u003e\u003cspan style\u003d\"margin-right: 10px;\"\u003eSP:\u003c/span\u003e\u003cb\u003e\u0027 + formatValue(series[2][dataPointIndex]) + \u0027\u003c/b\u003e\u003c/div\u003e\u0027\n\t                 \n\t\n\t    return htmlContent;\n\t}\u0027\u0027\u0027\n\t\n\t\n\treturn script",
                      "type": "script"
                    }
                  ],
                  "type": "expr"
                }
              },
              "props.options.yaxis[0].max": {
                "binding": {
                  "config": {
                    "path": "view.custom.day_data"
                  },
                  "transforms": [
                    {
                      "code": "\ttry:\n\t\tif self.parent.parent.getChild(\"Settings\").getChild(\"Fix Scale\").props.selected:\n\t\t\treturn self.view.custom.line.MaxWeight\n\t\telse:\n\t\t\t# Extract weight_max values from each row and find the maximum\n\t\t    max_weight \u003d max(row[\u0027weight_max\u0027] for row in value)\n\t\t    return max_weight\n\texcept:\n\t\treturn 100",
                      "type": "script"
                    }
                  ],
                  "type": "property"
                }
              },
              "props.options.yaxis[0].min": {
                "binding": {
                  "config": {
                    "path": "view.custom.day_data"
                  },
                  "transforms": [
                    {
                      "code": "\ttry:\n\t\tif self.parent.parent.getChild(\"Settings\").getChild(\"Fix Scale\").props.selected:\n\t\t\treturn self.view.custom.line.MinWeight\n\t\telse:\n\t\t\t# Extract weight_max values from each row and find the maximum\n\t\t    min_weight \u003d min(row[\u0027weight_min\u0027] for row in value)\n\t\t    return min_weight\n\texcept:\n\t\treturn 0",
                      "type": "script"
                    }
                  ],
                  "type": "property"
                }
              },
              "props.options.yaxis[2].max": {
                "binding": {
                  "config": {
                    "path": "this.props.options.yaxis[0].max"
                  },
                  "type": "property"
                }
              },
              "props.options.yaxis[2].min": {
                "binding": {
                  "config": {
                    "path": "this.props.options.yaxis[0].min"
                  },
                  "type": "property"
                }
              },
              "props.series[0].data": {
                "binding": {
                  "config": {
                    "path": "view.custom.aggregator_day"
                  },
                  "type": "property"
                }
              },
              "props.series[1].data": {
                "binding": {
                  "config": {
                    "path": "view.custom.aggregator_day_bag"
                  },
                  "type": "property"
                }
              },
              "props.series[2].data": {
                "binding": {
                  "config": {
                    "path": "view.custom.aggregator_day_sp"
                  },
                  "type": "property"
                }
              }
            },
            "props": {
              "options": {
                "annotations": {},
                "chart": {
                  "animations": {
                    "enabled": false
                  },
                  "background": "",
                  "events": {
                    "dataPointSelection": true
                  },
                  "fontFamily": "Roboto",
                  "foreColor": "#333",
                  "height": 220,
                  "id": "",
                  "toolbar": {
                    "show": false
                  },
                  "type": "boxPlot",
                  "width": 480
                },
                "colors": [
                  "#AAAAAA50"
                ],
                "dataLabels": {
                  "enabled": false,
                  "formatter": "function (value) {return value.toFixed(0).toLocaleString()}",
                  "style": {
                    "fontWeight": 700
                  }
                },
                "grid": {
                  "padding": {
                    "left": 15,
                    "right": 25
                  }
                },
                "legend": {
                  "fontSize": 14,
                  "itemMargin": {
                    "vertical": 0
                  },
                  "markers": {
                    "offsetY": 2,
                    "shape": "square",
                    "size": 10
                  },
                  "offsetY": 0,
                  "show": false
                },
                "markers": {
                  "colors": [
                    "#FF0000",
                    "#FF0000",
                    "#FF00FF"
                  ],
                  "shape": [
                    "circle",
                    "circle",
                    "square"
                  ],
                  "size": [
                    0,
                    0,
                    1
                  ]
                },
                "plotOptions": {
                  "boxPlot": {
                    "colors": {
                      "lower": "#4169E1",
                      "upper": "#B22222"
                    }
                  }
                },
                "stroke": {
                  "colors": [
                    "#555555",
                    "#555555",
                    "#FF00FF"
                  ],
                  "curve": [
                    "straight",
                    "straight",
                    "straight"
                  ],
                  "dashArray": [
                    0,
                    0,
                    5
                  ],
                  "width": [
                    0.5,
                    0,
                    1
                  ]
                },
                "title": {
                  "align": "center"
                },
                "tooltip": {
                  "enabled": true,
                  "followCursor": false,
                  "marker": {
                    "show": false
                  },
                  "shared": false,
                  "x": {
                    "show": true
                  }
                },
                "xaxis": {
                  "tooltip": {
                    "enabled": false
                  },
                  "type": "category"
                },
                "yaxis": [
                  {
                    "forceNiceScale": true,
                    "opposite": false,
                    "title": {
                      "text": "Weight"
                    }
                  },
                  {
                    "forceNiceScale": true,
                    "opposite": true,
                    "title": {
                      "text": "Units"
                    }
                  },
                  {
                    "forceNiceScale": true,
                    "opposite": false,
                    "show": false,
                    "title": {
                      "text": "SP"
                    }
                  }
                ]
              },
              "series": [
                {
                  "name": "Weight",
                  "type": "boxPlot"
                },
                {
                  "name": "Units",
                  "type": "area"
                },
                {
                  "name": "SP",
                  "type": "line"
                }
              ],
              "type": "boxPlot"
            },
            "type": "kyvislabs.display.apexchart"
          }
        ],
        "meta": {
          "name": "Day"
        },
        "position": {
          "basis": "500px",
          "shrink": 0
        },
        "propConfig": {
          "position.display": {
            "binding": {
              "config": {
                "path": "view.custom.selection.timestamp"
              },
              "transforms": [
                {
                  "code": "\tif value\u003d\u003d\u0027\u0027:\n\t\treturn False\n\telse:\n\t\treturn True",
                  "type": "script"
                }
              ],
              "type": "property"
            }
          }
        },
        "props": {
          "direction": "column",
          "style": {
            "borderColor": "#808080",
            "borderStyle": "solid",
            "borderWidth": 0.5,
            "marginBottom": 5,
            "marginLeft": 5,
            "marginRight": 5,
            "marginTop": 5,
            "overflow": "hidden",
            "overflowX": "hidden",
            "overflowY": "hidden"
          }
        },
        "type": "ia.container.flex"
      },
      {
        "children": [
          {
            "events": {
              "dom": {
                "onClick": {
                  "config": {
                    "script": "\tself.parent.parent.getChild(\"Day\").getChild(\"dailychart\").refreshBinding(\"props.options.yaxis[0].min\")\n\tself.parent.parent.getChild(\"Day\").getChild(\"dailychart\").refreshBinding(\"props.options.yaxis[0].max\")"
                  },
                  "scope": "G",
                  "type": "script"
                }
              }
            },
            "meta": {
              "name": "Fix Scale"
            },
            "position": {
              "basis": "132px"
            },
            "props": {
              "style": {
                "classes": "Weight_S/Framework/Card/Label"
              },
              "text": "Fix weight scale"
            },
            "type": "ia.input.checkbox"
          }
        ],
        "meta": {
          "name": "Settings"
        },
        "position": {
          "basis": "32px",
          "shrink": 0
        },
        "propConfig": {
          "position.display": {
            "binding": {
              "config": {
                "path": "view.custom.selection.timestamp"
              },
              "transforms": [
                {
                  "code": "\tif value\u003d\u003d\u0027\u0027:\n\t\treturn False\n\telse:\n\t\treturn True",
                  "type": "script"
                }
              ],
              "type": "property"
            }
          }
        },
        "props": {
          "justify": "center",
          "style": {
            "borderColor": "#808080",
            "borderStyle": "solid",
            "borderWidth": 0.5,
            "marginBottom": 5,
            "marginLeft": 5,
            "marginRight": 5,
            "marginTop": 5,
            "overflow": "hidden",
            "overflowX": "hidden",
            "overflowY": "hidden"
          }
        },
        "type": "ia.container.flex"
      },
      {
        "children": [
          {
            "events": {
              "component": {
                "dataPointSelectionHandler": {
                  "config": {
                    "script": "\n    from java.util import Calendar, TimeZone\n\n    # Get the timezone ID from a session property or another source\n    timeZoneId \u003d self.view.params.timeZoneID\n    tz \u003d TimeZone.getTimeZone(timeZoneId)\n    \n    #Hide if no data exists for selected day\n\t\n    # Check if no data exists for the selected day\n    if self.props.series[event.seriesIndex].data[event.dataPointIndex].y \u003d\u003d 0:\n    \tself.view.custom.selection.timestamp \u003d \u0027\u0027\n        self.view.custom.selection.index_series \u003d \u0027\u0027\n        self.view.custom.selection.index_day \u003d \u0027\u0027\n        self.view.custom.selection.index_year \u003d \u0027\u0027\n        return  # Exit the function if no data\n\t\n\t# Hide with second click on same day\n    if event.seriesIndex \u003d\u003d self.view.custom.selection.index_series and event.dataPointIndex \u003d\u003d self.view.custom.selection.index_day:\n        self.view.custom.selection.timestamp \u003d \u0027\u0027\n        self.view.custom.selection.index_series \u003d \u0027\u0027\n        self.view.custom.selection.index_day \u003d \u0027\u0027\n        self.view.custom.selection.index_year \u003d \u0027\u0027\n        return\n    \n    # Retrieve the year from the series data\n    series_year \u003d self.props.series[event.seriesIndex].year\n\n    # Convert to seconds for Python datetime operations\n    timestamp_seconds \u003d self.props.series[event.seriesIndex].data[event.dataPointIndex].x / 1000.0\n    \n    # Create a calendar instance, set the time and adjust to the specified timezone\n    calendar \u003d Calendar.getInstance(tz)\n    calendar.setTimeInMillis(long(timestamp_seconds * 1000))\n    \n    # Correctly set the year based on the series data\n    calendar.set(Calendar.YEAR, series_year)\n    \n    # Set hour, minute, second, and millisecond to 0 to get the start of the day\n    calendar.set(Calendar.HOUR_OF_DAY, 0)\n    calendar.set(Calendar.MINUTE, 0)\n    calendar.set(Calendar.SECOND, 0)\n    calendar.set(Calendar.MILLISECOND, 0)\n    \n    # Convert back to epoch milliseconds adjusted for the specified timezone\n    midnight_timestamp \u003d calendar.getTimeInMillis()\n    self.view.custom.selection.timestamp \u003d midnight_timestamp\n    \n    self.view.custom.selection.index_series \u003d event.seriesIndex\n    self.view.custom.selection.index_day \u003d event.dataPointIndex\n    self.view.custom.selection.index_year \u003d series_year\n\t\n\n\t\n\n\n"
                  },
                  "scope": "G",
                  "type": "script"
                }
              }
            },
            "meta": {
              "name": "heatmap"
            },
            "position": {
              "basis": "100%",
              "shrink": 0
            },
            "propConfig": {
              "props.options.dataLabels.formatter": {
                "binding": {
                  "config": {
                    "struct": {
                      "factor": "{view.custom.scale.conversion_factor}",
                      "stat": "{.../Selections/selection_stat.props.value}"
                    },
                    "waitOnAll": true
                  },
                  "transforms": [
                    {
                      "code": "\t\n\tif value[\u0027factor\u0027] \u003d\u003d 1:\n\t    digits \u003d str(0)\n\telif value[\u0027factor\u0027] \u003e 10:\n\t    digits \u003d str(1)\n\telif value[\u0027factor\u0027] \u003e 100:\n\t    digits \u003d str(2)\n\t\n\t    \n\tif value[\u0027stat\u0027] \u003d\u003d \u0027weight_avg\u0027:\n\t    \n\t    return \u0027\u0027\u0027function(val, opts) {\n\t        // Retrieve y2 value from the opts object\n\t        var y2 \u003d opts.w.config.series[opts.seriesIndex].data[opts.dataPointIndex].y2;\n\t        // Format y2 to a fixed number with no decimal places\n\t        var formattedY2 \u003d y2.toFixed(\u0027\u0027\u0027+digits+\u0027\u0027\u0027);\n\t        // Return formatted number as a localized string\n\t        return formattedY2.toLocaleString();\n\t    }\u0027\u0027\u0027\n\t    \n\tif value[\u0027stat\u0027] \u003d\u003d \u0027weight_diff\u0027:\n\t    \n\t    return \u0027\u0027\u0027function(val, opts) {\n\t        // Retrieve y3 value from the opts object\n\t        var y3 \u003d opts.w.config.series[opts.seriesIndex].data[opts.dataPointIndex].y3;\n\t        // Format y3 to a fixed number with no decimal places\n\t        var formattedY3 \u003d y3.toFixed(0);\n\t        // Return formatted number as a localized string\n\t        return formattedY3.toLocaleString();\n\t    }\u0027\u0027\u0027\n\t    \n\tif value[\u0027stat\u0027] \u003d\u003d \u0027count\u0027:\n\t    \n\t    return \u0027\u0027\u0027function(val, opts) {\n\t        // Retrieve y4 value from the opts object\n\t        var y4 \u003d opts.w.config.series[opts.seriesIndex].data[opts.dataPointIndex].y4;\n\t        // Format y4 to a fixed number with no decimal places\n\t        var formattedY4 \u003d y4.toFixed(1);\n\t        // Return formatted number as a localized string\n\t        return formattedY4.toLocaleString();\n\t        }\u0027\u0027\u0027",
                      "type": "script"
                    }
                  ],
                  "type": "expr-struct"
                }
              },
              "props.options.title.text": {
                "binding": {
                  "config": {
                    "struct": {
                      "description": "{view.custom.line.Description}",
                      "scale": "{view.custom.scale.scale_name}",
                      "unit": "{view.custom.scale.unit}"
                    },
                    "waitOnAll": true
                  },
                  "transforms": [
                    {
                      "code": "\tif value[\u0027description\u0027] !\u003d \u0027\u0027:\n\t\treturn  value[\u0027description\u0027] + \u0027 - Metal Detector Rejects\u0027 # + value[\u0027scale\u0027] + \u0027 - Weights are in \u0027 + value[\u0027unit\u0027] + \u0027. Overage is in kg. Filler accuracy σ set to: \u0027 + str(self.view.custom.scale.design) + \u0027 \u0027 + value[\u0027unit\u0027]\n\telse:\n\t\treturn \u0027Metal Detector Rejects\u0027 # \u0027Weights are in \u0027 + value[\u0027unit\u0027] + \u0027. Overage is in kg. Filler accuracy σ set to: \u0027 + str(self.view.custom.scale.design) + \u0027 \u0027 + value[\u0027unit\u0027]",
                      "type": "script"
                    }
                  ],
                  "type": "expr-struct"
                }
              },
              "props.options.tooltip.y.formatter": {
                "binding": {
                  "config": {
                    "expression": "{view.custom.scale.unit}"
                  },
                  "transforms": [
                    {
                      "code": "\n    # Convert the Python variable \u0027value\u0027 to a string and prepare it for JavaScript injection\n    value_str \u003d str(value)\n    \n    \n    # Create the JavaScript function as a string, injecting \u0027value\u0027 correctly\n    return (\u0027\u0027\u0027function(value, { series, seriesIndex, dataPointIndex, w }) {\u0027\u0027\u0027\n            \u0027\u0027\u0027\\n    // Accessing the data for y, y2, y3, and y4\u0027\u0027\u0027\n            \u0027\u0027\u0027\\n    var data \u003d w.config.series[seriesIndex].data[dataPointIndex];\u0027\u0027\u0027\n            \u0027\u0027\u0027\\n    var y \u003d parseFloat(data.y).toFixed(0);  // Main value\u0027\u0027\u0027\n            \u0027\u0027\u0027\\n    var y2 \u003d parseFloat(data.y2).toFixed(0); // Additional value 1\u0027\u0027\u0027\n            \u0027\u0027\u0027\\n    var y3 \u003d parseFloat(data.y3).toFixed(1); // Additional value 2\u0027\u0027\u0027\n            \u0027\u0027\u0027\\n    var y4 \u003d parseFloat(data.y4).toFixed(0); // Additional value 3\u0027\u0027\u0027\n            \u0027\u0027\u0027\\n    var pc \u003d 0\u0027\u0027\u0027\n            \u0027\u0027\u0027\\n    if (parseFloat(data.y4)\u003e0){\u0027\u0027\u0027\n            \u0027\u0027\u0027\\n    pc \u003d (parseFloat(data.y)*100/parseFloat(data.y4)).toFixed(0);} // Percentage\u0027\u0027\u0027\n            \u0027\u0027\u0027\\n\u0027\u0027\u0027\n            \u0027\u0027\u0027\\n    // Concatenate the values with slashes in between\u0027\u0027\u0027\n            \u0027\u0027\u0027\\n    return \u0027Metal Detected in \u0027 + y + \u0027 units out of \u0027 + y4 + \u0027 (\u0027 + pc + \u0027%)\u0027; \u0027\u0027\u0027\n            \u0027\u0027\u0027\\n}\u0027\u0027\u0027)\n            \n            \n            \n            #\u0027\u0027\u0027\\n    return \u0027Avg. Overage: \u0027 + y + \" \u0027\u0027\u0027 + value_str + \u0027\u0027\u0027 \" + \u0027 / Avg. Weight: \u0027 + y2 + \" \u0027\u0027\u0027 + value_str + \u0027\u0027\u0027 \"  + \u0027 / Overage: \u0027 + y3+ \" kg \"   + \u0027 / Units: \u0027 + y4;\u0027\u0027\u0027",
                      "type": "script"
                    }
                  ],
                  "type": "expr"
                }
              },
              "props.series": {
                "binding": {
                  "config": {
                    "path": "view.custom.aggregator_year_metal_rejects"
                  },
                  "type": "property"
                }
              }
            },
            "props": {
              "options": {
                "annotations": {},
                "chart": {
                  "animations": {
                    "enabled": false
                  },
                  "background": "",
                  "events": {
                    "dataPointSelection": true
                  },
                  "fontFamily": "Roboto",
                  "foreColor": "#333",
                  "height": 220,
                  "toolbar": {
                    "show": false,
                    "tools": {
                      "zoom": false,
                      "zoomin": false,
                      "zoomout": false
                    }
                  },
                  "type": "heatmap",
                  "width": 480
                },
                "colors": [
                  "#FF0000"
                ],
                "dataLabels": {
                  "enabled": true,
                  "style": {
                    "fontSize": "10px",
                    "fontWeight": 700
                  }
                },
                "grid": {
                  "padding": {
                    "left": 15,
                    "right": 25
                  }
                },
                "legend": {
                  "fontSize": 14,
                  "itemMargin": {
                    "vertical": 0
                  },
                  "markers": {
                    "offsetY": 2,
                    "shape": "square",
                    "size": 10
                  },
                  "offsetY": 0,
                  "show": false
                },
                "plotOptions": {
                  "heatmap": {
                    "colorScale": {
                      "inverse": true,
                      "max": 0,
                      "min": 2000,
                      "ranges": [
                        {
                          "color": "#FFFFFF",
                          "foreColor": "#FFFFFF",
                          "from": 0,
                          "name": " ",
                          "to": 0
                        },
                        {
                          "color": "#ABCDEF",
                          "foreColor": "#000000",
                          "from": 1,
                          "name": "Metal Detection events",
                          "to": 1000
                        }
                      ]
                    },
                    "distributed": false,
                    "enableShades": true,
                    "radius": 2,
                    "reverseNegativeShade": false,
                    "shadeIntensity": 0.8,
                    "useFillColorAsStroke": false
                  }
                },
                "stroke": {
                  "colors": [
                    "#fff"
                  ],
                  "fill": {
                    "gradient": {
                      "colorStops": [],
                      "inverseColors": true,
                      "opacityFrom": 1,
                      "opacityTo": 1,
                      "shade": "dark",
                      "shadeIntensity": 0.5,
                      "stops": [
                        0,
                        50,
                        100
                      ],
                      "type": "horizontal"
                    },
                    "opacity": 0.85,
                    "type": "solid"
                  }
                },
                "theme": {
                  "palette": "palette4"
                },
                "title": {
                  "align": "center",
                  "style": {
                    "color": "#263238",
                    "fontFamily": "Roboto",
                    "fontSize": "18px",
                    "fontWeight": "bold"
                  }
                },
                "tooltip": {
                  "enabled": true,
                  "followCursor": true,
                  "marker": {
                    "show": true
                  },
                  "x": {
                    "show": true
                  },
                  "y": {
                    "show": true
                  }
                },
                "xaxis": {
                  "axisTicks": {
                    "show": false
                  },
                  "decimalsInFloat": 0,
                  "labels": {
                    "show": false,
                    "style": {},
                    "trim": true
                  },
                  "tickAmount": 31,
                  "tickPlacement": "numeric",
                  "title": {
                    "style": {
                      "fontWeight": 700
                    }
                  },
                  "tooltip": {
                    "enabled": false
                  },
                  "type": "datetime"
                },
                "yaxis": {
                  "labels": {
                    "style": {}
                  },
                  "tickAmount": 5,
                  "title": {
                    "style": {
                      "fontWeight": 700
                    }
                  }
                }
              },
              "style": {
                "marginBottom": 10,
                "marginLeft": 10,
                "marginRight": 10,
                "marginTop": 10
              },
              "type": "heatmap"
            },
            "type": "kyvislabs.display.apexchart"
          }
        ],
        "meta": {
          "name": "Year_Metal_Rejects"
        },
        "position": {
          "shrink": 0
        },
        "propConfig": {
          "position.basis": {
            "binding": {
              "config": {
                "expression": "concat(toStr(((len({./heatmap.props.series})+2)*25)),\u0027px\u0027)"
              },
              "type": "expr"
            }
          },
          "position.display": {
            "binding": {
              "config": {
                "expression": "if({../Selections/selection_scale.props.value}\u003d0,True, False)"
              },
              "type": "expr"
            }
          }
        },
        "props": {
          "alignContent": "flex-start",
          "style": {
            "borderColor": "#808080",
            "borderStyle": "solid",
            "borderWidth": 0.5,
            "marginBottom": 5,
            "marginLeft": 5,
            "marginRight": 5,
            "marginTop": 5,
            "overflow": "hidden",
            "overflowX": "hidden",
            "overflowY": "hidden"
          }
        },
        "type": "ia.container.flex"
      },
      {
        "children": [
          {
            "events": {
              "component": {
                "dataPointSelectionHandler": {
                  "config": {
                    "script": "\n    from java.util import Calendar, TimeZone\n\n    # Get the timezone ID from a session property or another source\n    timeZoneId \u003d self.view.params.timeZoneID\n    tz \u003d TimeZone.getTimeZone(timeZoneId)\n    \n    #Hide if no data exists for selected day\n\t\n    # Check if no data exists for the selected day\n    if self.props.series[event.seriesIndex].data[event.dataPointIndex].y \u003d\u003d 0:\n    \tself.view.custom.selection.timestamp \u003d \u0027\u0027\n        self.view.custom.selection.index_series \u003d \u0027\u0027\n        self.view.custom.selection.index_day \u003d \u0027\u0027\n        self.view.custom.selection.index_year \u003d \u0027\u0027\n        return  # Exit the function if no data\n\t\n\t# Hide with second click on same day\n    if event.seriesIndex \u003d\u003d self.view.custom.selection.index_series and event.dataPointIndex \u003d\u003d self.view.custom.selection.index_day:\n        self.view.custom.selection.timestamp \u003d \u0027\u0027\n        self.view.custom.selection.index_series \u003d \u0027\u0027\n        self.view.custom.selection.index_day \u003d \u0027\u0027\n        self.view.custom.selection.index_year \u003d \u0027\u0027\n        return\n    \n    # Retrieve the year from the series data\n    series_year \u003d self.props.series[event.seriesIndex].year\n\n    # Convert to seconds for Python datetime operations\n    timestamp_seconds \u003d self.props.series[event.seriesIndex].data[event.dataPointIndex].x / 1000.0\n    \n    # Create a calendar instance, set the time and adjust to the specified timezone\n    calendar \u003d Calendar.getInstance(tz)\n    calendar.setTimeInMillis(long(timestamp_seconds * 1000))\n    \n    # Correctly set the year based on the series data\n    calendar.set(Calendar.YEAR, series_year)\n    \n    # Set hour, minute, second, and millisecond to 0 to get the start of the day\n    calendar.set(Calendar.HOUR_OF_DAY, 0)\n    calendar.set(Calendar.MINUTE, 0)\n    calendar.set(Calendar.SECOND, 0)\n    calendar.set(Calendar.MILLISECOND, 0)\n    \n    # Convert back to epoch milliseconds adjusted for the specified timezone\n    midnight_timestamp \u003d calendar.getTimeInMillis()\n    self.view.custom.selection.timestamp \u003d midnight_timestamp\n    \n    self.view.custom.selection.index_series \u003d event.seriesIndex\n    self.view.custom.selection.index_day \u003d event.dataPointIndex\n    self.view.custom.selection.index_year \u003d series_year\n\t\n\n\t\n\n\n"
                  },
                  "scope": "G",
                  "type": "script"
                }
              }
            },
            "meta": {
              "name": "heatmap"
            },
            "position": {
              "basis": "100%",
              "shrink": 0
            },
            "propConfig": {
              "props.options.dataLabels.formatter": {
                "binding": {
                  "config": {
                    "struct": {
                      "factor": "{view.custom.scale.conversion_factor}",
                      "stat": "{.../Selections/selection_stat.props.value}"
                    },
                    "waitOnAll": true
                  },
                  "transforms": [
                    {
                      "code": "\t\n\tif value[\u0027factor\u0027] \u003d\u003d 1:\n\t    digits \u003d str(0)\n\telif value[\u0027factor\u0027] \u003e 10:\n\t    digits \u003d str(1)\n\telif value[\u0027factor\u0027] \u003e 100:\n\t    digits \u003d str(2)\n\t\n\t    \n\tif value[\u0027stat\u0027] \u003d\u003d \u0027weight_avg\u0027:\n\t    \n\t    return \u0027\u0027\u0027function(val, opts) {\n\t        // Retrieve y2 value from the opts object\n\t        var y2 \u003d opts.w.config.series[opts.seriesIndex].data[opts.dataPointIndex].y2;\n\t        // Format y2 to a fixed number with no decimal places\n\t        var formattedY2 \u003d y2.toFixed(\u0027\u0027\u0027+digits+\u0027\u0027\u0027);\n\t        // Return formatted number as a localized string\n\t        return formattedY2.toLocaleString();\n\t    }\u0027\u0027\u0027\n\t    \n\tif value[\u0027stat\u0027] \u003d\u003d \u0027weight_diff\u0027:\n\t    \n\t    return \u0027\u0027\u0027function(val, opts) {\n\t        // Retrieve y3 value from the opts object\n\t        var y3 \u003d opts.w.config.series[opts.seriesIndex].data[opts.dataPointIndex].y3;\n\t        // Format y3 to a fixed number with no decimal places\n\t        var formattedY3 \u003d y3.toFixed(0);\n\t        // Return formatted number as a localized string\n\t        return formattedY3.toLocaleString();\n\t    }\u0027\u0027\u0027\n\t    \n\tif value[\u0027stat\u0027] \u003d\u003d \u0027count\u0027:\n\t    \n\t    return \u0027\u0027\u0027function(val, opts) {\n\t        // Retrieve y4 value from the opts object\n\t        var y4 \u003d opts.w.config.series[opts.seriesIndex].data[opts.dataPointIndex].y4;\n\t        // Format y4 to a fixed number with no decimal places\n\t        var formattedY4 \u003d y4.toFixed(1);\n\t        // Return formatted number as a localized string\n\t        return formattedY4.toLocaleString();\n\t        }\u0027\u0027\u0027",
                      "type": "script"
                    }
                  ],
                  "type": "expr-struct"
                }
              },
              "props.options.title.text": {
                "binding": {
                  "config": {
                    "struct": {
                      "description": "{view.custom.line.Description}",
                      "scale": "{view.custom.scale.scale_name}",
                      "unit": "{view.custom.scale.unit}"
                    },
                    "waitOnAll": true
                  },
                  "transforms": [
                    {
                      "code": "\tif value[\u0027description\u0027] !\u003d \u0027\u0027:\n\t\treturn  value[\u0027description\u0027] + \u0027 - Weight Rejects\u0027 # + value[\u0027scale\u0027] + \u0027 - Weights are in \u0027 + value[\u0027unit\u0027] + \u0027. Overage is in kg. Filler accuracy σ set to: \u0027 + str(self.view.custom.scale.design) + \u0027 \u0027 + value[\u0027unit\u0027]\n\telse:\n\t\treturn \u0027Weight Rejects\u0027 # \u0027Weights are in \u0027 + value[\u0027unit\u0027] + \u0027. Overage is in kg. Filler accuracy σ set to: \u0027 + str(self.view.custom.scale.design) + \u0027 \u0027 + value[\u0027unit\u0027]",
                      "type": "script"
                    }
                  ],
                  "type": "expr-struct"
                }
              },
              "props.options.tooltip.y.formatter": {
                "binding": {
                  "config": {
                    "expression": "{view.custom.scale.unit}"
                  },
                  "transforms": [
                    {
                      "code": "\n    # Convert the Python variable \u0027value\u0027 to a string and prepare it for JavaScript injection\n    value_str \u003d str(value)\n    \n    \n    # Create the JavaScript function as a string, injecting \u0027value\u0027 correctly\n    return (\u0027\u0027\u0027function(value, { series, seriesIndex, dataPointIndex, w }) {\u0027\u0027\u0027\n            \u0027\u0027\u0027\\n    // Accessing the data for y, y2, y3, and y4\u0027\u0027\u0027\n            \u0027\u0027\u0027\\n    var data \u003d w.config.series[seriesIndex].data[dataPointIndex];\u0027\u0027\u0027\n            \u0027\u0027\u0027\\n    var y \u003d parseFloat(data.y).toFixed(0);  // Main value\u0027\u0027\u0027\n            \u0027\u0027\u0027\\n    var y2 \u003d parseFloat(data.y2).toFixed(0); // Additional value 1\u0027\u0027\u0027\n            \u0027\u0027\u0027\\n    var y3 \u003d parseFloat(data.y3).toFixed(1); // Additional value 2\u0027\u0027\u0027\n            \u0027\u0027\u0027\\n    var y4 \u003d parseFloat(data.y4).toFixed(0); // Additional value 3\u0027\u0027\u0027\n            \u0027\u0027\u0027\\n    var pc \u003d 0\u0027\u0027\u0027\n            \u0027\u0027\u0027\\n    if (parseFloat(data.y4)\u003e0){\u0027\u0027\u0027\n            \u0027\u0027\u0027\\n    pc \u003d (parseFloat(data.y)*100/parseFloat(data.y4)).toFixed(0);} // Percentage\u0027\u0027\u0027\n            \u0027\u0027\u0027\\n\u0027\u0027\u0027\n            \u0027\u0027\u0027\\n    // Concatenate the values with slashes in between\u0027\u0027\u0027\n            \u0027\u0027\u0027\\n    return \u0027Weight Rejects for \u0027 + y + \u0027 units out of \u0027 + y4 + \u0027 (\u0027 + pc + \u0027%)\u0027; \u0027\u0027\u0027\n            \u0027\u0027\u0027\\n}\u0027\u0027\u0027)\n            \n            \n            \n            #\u0027\u0027\u0027\\n    return \u0027Avg. Overage: \u0027 + y + \" \u0027\u0027\u0027 + value_str + \u0027\u0027\u0027 \" + \u0027 / Avg. Weight: \u0027 + y2 + \" \u0027\u0027\u0027 + value_str + \u0027\u0027\u0027 \"  + \u0027 / Overage: \u0027 + y3+ \" kg \"   + \u0027 / Units: \u0027 + y4;\u0027\u0027\u0027",
                      "type": "script"
                    }
                  ],
                  "type": "expr"
                }
              },
              "props.series": {
                "binding": {
                  "config": {
                    "path": "view.custom.aggregator_year_weight_rejects"
                  },
                  "type": "property"
                }
              }
            },
            "props": {
              "options": {
                "annotations": {},
                "chart": {
                  "animations": {
                    "enabled": false
                  },
                  "background": "",
                  "events": {
                    "dataPointSelection": true
                  },
                  "fontFamily": "Roboto",
                  "foreColor": "#333",
                  "height": 220,
                  "toolbar": {
                    "show": false,
                    "tools": {
                      "zoom": false,
                      "zoomin": false,
                      "zoomout": false
                    }
                  },
                  "type": "heatmap",
                  "width": 480
                },
                "colors": [
                  "#FF0000"
                ],
                "dataLabels": {
                  "enabled": true,
                  "style": {
                    "fontSize": "10px",
                    "fontWeight": 700
                  }
                },
                "grid": {
                  "padding": {
                    "left": 15,
                    "right": 25
                  }
                },
                "legend": {
                  "fontSize": 14,
                  "itemMargin": {
                    "vertical": 0
                  },
                  "markers": {
                    "offsetY": 2,
                    "shape": "square",
                    "size": 10
                  },
                  "offsetY": 0,
                  "show": false
                },
                "plotOptions": {
                  "heatmap": {
                    "colorScale": {
                      "inverse": true,
                      "max": 0,
                      "min": 2000,
                      "ranges": [
                        {
                          "color": "#FFFFFF",
                          "foreColor": "#FFFFFF",
                          "from": 0,
                          "name": " ",
                          "to": 0
                        },
                        {
                          "color": "#ABCDEF",
                          "foreColor": "#000000",
                          "from": 1,
                          "name": "Metal Detection events",
                          "to": 1000
                        }
                      ]
                    },
                    "distributed": false,
                    "enableShades": true,
                    "radius": 2,
                    "reverseNegativeShade": false,
                    "shadeIntensity": 0.8,
                    "useFillColorAsStroke": false
                  }
                },
                "stroke": {
                  "colors": [
                    "#fff"
                  ],
                  "fill": {
                    "gradient": {
                      "colorStops": [],
                      "inverseColors": true,
                      "opacityFrom": 1,
                      "opacityTo": 1,
                      "shade": "dark",
                      "shadeIntensity": 0.5,
                      "stops": [
                        0,
                        50,
                        100
                      ],
                      "type": "horizontal"
                    },
                    "opacity": 0.85,
                    "type": "solid"
                  }
                },
                "theme": {
                  "palette": "palette4"
                },
                "title": {
                  "align": "center",
                  "style": {
                    "color": "#263238",
                    "fontFamily": "Roboto",
                    "fontSize": "18px",
                    "fontWeight": "bold"
                  }
                },
                "tooltip": {
                  "enabled": true,
                  "followCursor": true,
                  "marker": {
                    "show": true
                  },
                  "x": {
                    "show": true
                  },
                  "y": {
                    "show": true
                  }
                },
                "xaxis": {
                  "axisTicks": {
                    "show": false
                  },
                  "decimalsInFloat": 0,
                  "labels": {
                    "show": false,
                    "style": {},
                    "trim": true
                  },
                  "tickAmount": 31,
                  "tickPlacement": "numeric",
                  "title": {
                    "style": {
                      "fontWeight": 700
                    }
                  },
                  "tooltip": {
                    "enabled": false
                  },
                  "type": "datetime"
                },
                "yaxis": {
                  "labels": {
                    "style": {}
                  },
                  "tickAmount": 5,
                  "title": {
                    "style": {
                      "fontWeight": 700
                    }
                  }
                }
              },
              "style": {
                "marginBottom": 10,
                "marginLeft": 10,
                "marginRight": 10,
                "marginTop": 10
              },
              "type": "heatmap"
            },
            "type": "kyvislabs.display.apexchart"
          }
        ],
        "meta": {
          "name": "Year_Weight_Rejects"
        },
        "position": {
          "shrink": 0
        },
        "propConfig": {
          "position.basis": {
            "binding": {
              "config": {
                "expression": "concat(toStr(((len({./heatmap.props.series})+2)*25)),\u0027px\u0027)"
              },
              "type": "expr"
            }
          },
          "position.display": {
            "binding": {
              "config": {
                "expression": "if({../Selections/selection_scale.props.value}\u003d0,True, False)"
              },
              "type": "expr"
            }
          }
        },
        "props": {
          "alignContent": "flex-start",
          "style": {
            "borderColor": "#808080",
            "borderStyle": "solid",
            "borderWidth": 0.5,
            "marginBottom": 5,
            "marginLeft": 5,
            "marginRight": 5,
            "marginTop": 5,
            "overflow": "hidden",
            "overflowX": "hidden",
            "overflowY": "hidden"
          }
        },
        "type": "ia.container.flex"
      }
    ],
    "meta": {
      "name": "root"
    },
    "props": {
      "direction": "column"
    },
    "type": "ia.container.flex"
  }
}